{
  "hash": "99ed7ce29df2f8137b942f3bb3f29123",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: QPSK-Sync\ntheme: \"cerulean\"\n# https://quarto.org/docs/dashboards/theming.html\nhighlight-style: github\nauthor: github.com/{patater, temataro}\ntoc:              true\nnumber-sections:  true\nformat:\n  html:\n    code-fold:    false\n    code-tools:   true\n---\n\n# Measuring the delay between two QPSK signals\n\n::: {#50cb4951 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import signal\n```\n:::\n\n\nIn this notebook, we'll create and send two overlapping pseudo-random QPSK signals over a noisy reception channel. We'll delay one of the signals relative to the other when simulating transmission. We'll recover this delay, with sub-sample accuracy, using correlation and measuring the distance between the peaks.\n\n## The transmit signals (TX1 and TX2)\n\n::: {#f1da97c2 .cell execution_count=2}\n``` {.python .cell-code}\nFs   = 20e6             # 20 MHz sample rate\nSPS  = 4                # Samples per symbol\nTaps = 61\n\ndef rc_filter(taps, beta=0.33):\n    Ts = SPS\n    t  = np.arange(taps)\n    t -= (taps - 1) // 2  # Center the indices around 0\n    h  = 1 / Ts\n    h *= np.sinc(t / Ts)\n    h *= np.cos(np.pi * beta * t / Ts)\n    h /= 1.0 - (2.0 * beta * t / Ts) ** 2\n    return h * np.sqrt(Taps)\n\n\ndef rrc_filter(taps, beta=0.33):\n    # Create an RC filter\n    hrc = rc_filter(taps, beta)\n\n    # Take the square root of the RC filter in the frequency domain to obtain the frequency response of the\n    # desired root raised cosine (RRC) filter.\n    Hrc = np.fft.fft(hrc)\n    Hrrc = np.sqrt(np.abs(Hrc))\n\n    # Perform an IFFT to obtain the impulse reponse. Optionally, we could use the frequency response directly\n    # and avoid the more expensive convolution operation to apply the filter (as multiplying in the frequency\n    # domain is equivalent to convolution in the time domain)\n    hrrc = np.fft.fftshift(np.fft.ifft(Hrrc))\n    return hrrc.real\n```\n:::\n\n\n::: {.callout-tip}\n# Why RRCs? Why not simple low pass filters?\nCreate and use a root raised cosine filter so that when the receiver also uses an RRC filter, the complete, end-to-end channel response is thatof a raised cosine filter, which is pretty good at minimizing inter-symbol interference (ISI).\n:::\n\n::: {#fig-rrc .cell layout-nrow='2' execution_count=3}\n``` {.python .cell-code}\npulse = rrc_filter(taps=Taps)\nt = np.arange(pulse.shape[0]) - (pulse.shape[0] - 1) / 2\n\nsp = np.fft.fftshift(np.fft.fft(pulse))\nfreq = np.fft.fftshift(np.fft.fftfreq(t.shape[0]))\n\nfig = plt.figure()\nplt.plot(t, pulse, \".-\")\nplt.ylabel(\"Magnitude\")\nplt.title(\"Impulse Response (Time Domain)\")\nplt.grid(True)\n\nfig = plt.figure()\nplt.plot(freq, np.abs(sp), \".-\")\nplt.ylabel(\"Magnitude\")\nplt.title(\"Frequency Response\")\nplt.grid(True)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![RC filter, beta=0.33](qpsk-sync_files/figure-html/fig-rrc-output-1.png){#fig-rrc-1 width=589 height=431}\n:::\n\n::: {.cell-output .cell-output-display}\n![RRC filter, beta=0.33](qpsk-sync_files/figure-html/fig-rrc-output-2.png){#fig-rrc-2 width=589 height=431}\n:::\n\n61 Tap RC and RRC Filter Magnitude Response\n:::\n\n\n:::{.callout-caution}\nAs a sidenote, observe that the units for the frequency response's x-axis aren't immediately obvious. (The time domain obviously has units in Ts where Ts is the sampling period.)\nWhen 'digitizing' an analog signal one must sample it leading to an implied assumption that everything happening before and after the samples were taken will repeat (the signal is periodic with period N). From this assumption, we get the digital frequency of the signal repeating (or in more technical terms, aliasing) around every 2$\\pi$ radians.\n\nOur frequency response (obtained by the DFT of the time domain signal) only extends between -$\\frac{\\pi}{2}$ and $\\frac{\\pi}{2}$.\nTo convert these into analog frequencies between $\\frac{-f_s}{2}$ and $\\frac{f_s}{2}$ use the formula:\n$$\\Omega = 2\\pi * \\frac{f}{f_s} $$\n:::\nLet's geneate our complex pseudo-random sequences (pulse trains).\nThe longer the sequence we create, the more confident we can be at the receiver end which TX signal we are seeing and when.\n\n::: {#d2e61ad7 .cell execution_count=4}\n``` {.python .cell-code code-fold=\"true\"}\nNs  = 2000       # Number of symbols to generate\nN   = Ns * SPS   # Number of samples\nBPS = 2          # QPSK has 2 bits per symbol\nNd  = 23         # Number of symbols to display\n\n\ndef gen_pulse_train():\n    sym = np.random.randint(0, BPS**2, Ns)\n    s = np.zeros(N, dtype=complex)\n\n    for i, ss in enumerate(sym):\n        s[i * SPS] += (ss & 0b01) - 0.5\n        s[i * SPS] += 1j * (((ss & 0b10) >> 1) - 0.5)\n    return s\n\n```\n:::\n\n\n::: {#random-bits .cell execution_count=5}\n``` {.python .cell-code code-fold=\"true\"}\nx = gen_pulse_train()\ny = gen_pulse_train()\n\n\nfig = plt.figure()\nplt.plot(np.real(x), \"r.-\")\nplt.plot(np.imag(x), \".-\")\nplt.ylabel(\"Value\")\nplt.title(\"Impulse train X\")\nplt.xlim((0, Nd))\nplt.ylim((-1, 1))\nplt.grid(True)\n\n\nOversampling = 25\nfig = plt.figure()\nplt.plot(np.repeat(np.real(x), Oversampling), \"r.-\")\nplt.plot(np.repeat(np.imag(x), Oversampling), \".-\")\nplt.ylabel(\"Value\")\nplt.title(\"Oversampled Impulse train X\")\nplt.xlim((0, Oversampling * Nd))\nplt.ylim((-1, 1))\nplt.grid(True)\n\n\nfig = plt.figure()\nplt.plot(np.real(y), \"r.-\")\nplt.plot(np.imag(y), \".-\")\nplt.ylabel(\"Value\")\nplt.title(\"Impulse train Y\")\nplt.xlim((0, Nd))\nplt.ylim((-1, 1))\nplt.grid(True)\n\n\nfig = plt.figure()\nplt.plot(np.repeat(np.real(y), Oversampling), \"r.-\")\nplt.plot(np.repeat(np.imag(y), Oversampling), \".-\")\nplt.ylabel(\"Value\")\nplt.title(\"Oversampled Impulse train Y\")\nplt.xlim((0, Oversampling * Nd))\nplt.ylim((-1, 1))\nplt.grid(True)\n```\n\n::: {.cell-output .cell-output-display}\n![Impulse Train X](qpsk-sync_files/figure-html/random-bits-output-1.png){#random-bits-1 width=608 height=431 fig-align='center'}\n:::\n\n::: {.cell-output .cell-output-display}\n![Impulse Train X Oversampled by 20 to see bits better](qpsk-sync_files/figure-html/random-bits-output-2.png){#random-bits-2 width=608 height=431 fig-align='center'}\n:::\n\n::: {.cell-output .cell-output-display}\n![Impulse Train Y](qpsk-sync_files/figure-html/random-bits-output-3.png){#random-bits-3 width=608 height=431 fig-align='center'}\n:::\n\n::: {.cell-output .cell-output-display}\n![Impulse Train Y Oversampled by 20 to see bits better](qpsk-sync_files/figure-html/random-bits-output-4.png){#random-bits-4 width=608 height=431 fig-align='center'}\n:::\n\nGenerated Random Impulse Trains\n:::\n\n\n#### Interlude: Representing QPSK data\nFor QPSK we have 4 symbols that we would like to represent as IQ data. Therefore, we need a mapping from the linear {0b00, 0b01, 0b10, 0b11} to a complex {(-0.5 - j*0.5), (0.5 - j*0.5), (-0.5 + j*0.5), (0.5 + j*0.5)}\n\n::: {#cell-QPSK .cell execution_count=6}\n\n::: {.cell-output .cell-output-display}\n![QPSK Constellation Diagram](qpsk-sync_files/figure-html/qpsk-output-1.png){#qpsk width=623 height=449 fig-align='center'}\n:::\n:::\n\n\n## Pulse Shaping Our Data\n\n::: {#pulse-shaping .cell execution_count=7}\n``` {.python .cell-code code-fold=\"true\"}\ntx1 = signal.convolve(x, pulse)\ntx2 = signal.convolve(y, pulse)\n\n# Convolution has the effect of making our signal a bit longer (N + Taps/2 - 1)\n\nt = np.arange(tx1.shape[0])\nfig = plt.figure()\nplt.plot(np.real(tx1), \"r.-\", np.imag(tx1), \".-\")\nplt.ylabel(\"Value\")\nplt.title(\"TX1\")\nplt.xlim((Taps//2, SPS * Nd))\nplt.grid(True)\n\nfig = plt.figure()\nplt.plot(np.real(tx2), \"r.-\", np.imag(tx2), \".-\")\nplt.ylabel(\"Value\")\nplt.title(\"TX2\")\nplt.xlim((Taps//2, SPS * Nd))\nplt.grid(True)\n```\n\n::: {.cell-output .cell-output-display}\n![Pulse shaped TX1](qpsk-sync_files/figure-html/pulse-shaping-output-1.png){#pulse-shaping-1 width=600 height=431 fig-align='center'}\n:::\n\n::: {.cell-output .cell-output-display}\n![Pulse shaped TX2](qpsk-sync_files/figure-html/pulse-shaping-output-2.png){#pulse-shaping-2 width=600 height=431 fig-align='center'}\n:::\n\nPulse shaped bits to be transmitted\n:::\n\n\n:::{.callout-note}\nWhat we see above are signals that are more resilient to inter-symbol interference due to the RRC filter we applied on both ends of our chain. A lowpass filter is applied before and after transmission to reduce the spectrum usage of our signal (and for noise resilience).\nA great article on the topic by Dr. Marc Lichtman can be found on [PySDR.org](https://pysdr.org/content/pulse_shaping.html).\n:::\n\n::: {#tx-iq-data .cell execution_count=8}\n``` {.python .cell-code code-fold=\"true\"}\nIQd = 500  # Raw IQ Samples to display\n\nfig = plt.figure()\nplt.title(\"TX1 IQ Constellation\")\nplt.ylabel(\"Quadrature\")\nplt.xlabel(\"In-phase\")\nplt.ylim((-1, 1))\nplt.xlim((-1, 1))\nplt.plot(np.real(tx1[Taps//2:IQd:SPS]), np.imag(tx1[Taps//2:IQd:SPS]), \".\")\nplt.plot(np.real(x[0::SPS]), np.imag(x[0::SPS]), \"r.\")\nplt.show()\n\nfig = plt.figure()\nplt.title(\"TX2 IQ Constellation\")\nplt.ylabel(\"Quadrature\")\nplt.xlabel(\"In-phase\")\nplt.ylim((-1, 1))\nplt.xlim((-1, 1))\nplt.plot(np.real(tx2[Taps//2:IQd:SPS]), np.imag(tx2[Taps//2:IQd:SPS]), \".\")\nplt.plot(np.real(y[0::SPS]), np.imag(y[0::SPS]), \"r.\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![IQ constellation for TX1](qpsk-sync_files/figure-html/tx-iq-data-output-1.png){#tx-iq-data-1 width=623 height=449 fig-align='center'}\n:::\n\n::: {.cell-output .cell-output-display}\n![IQ constellation for TX2](qpsk-sync_files/figure-html/tx-iq-data-output-2.png){#tx-iq-data-2 width=623 height=449 fig-align='center'}\n:::\n\nIQ samples of TX1 and TX2\n:::\n\n\nFrom the IQ diagrams, we can see that the two transmission signals are both clean QPSK.\n\n::: {#cell-TX-Correlation .cell execution_count=9}\n``` {.python .cell-code code-fold=\"true\"}\nac1 = signal.correlate(tx1, tx1)\nac2 = signal.correlate(tx2, tx2)\ncc = signal.correlate(tx1, tx2)\nac1 = signal.correlate(tx1, tx1)\nac2 = signal.correlate(tx2, tx2)\ncc = signal.correlate(tx1, tx2)\n\nt = np.arange(ac1.shape[0]) - (ac1.shape[0] - 1) / 2\ntop = np.max((np.abs(ac1), np.abs(ac2), np.abs(cc)))\n\nplt.figure(figsize=(16, 4))\nplt.subplot(131)\nplt.plot(t, np.abs(ac1), \".-\")\nplt.ylabel(\"Correlation\")\nplt.title(\"Autocorrelation TX1\")\nplt.xlim((-64, 63)) # Display the center 128 samples\nplt.ylim((0, top))\nplt.grid(True)\n\nplt.subplot(132)\nplt.plot(t, np.abs(cc), \".-\")\nplt.xlabel(\"Lag\")\nplt.title(\"Crosscorrelation TX1:TX2\")\nplt.xlim((-64, 63))\nplt.ylim((0, top))\nplt.grid(True)\n\nplt.subplot(133)\nplt.plot(t, np.abs(ac2), \".-\")\nplt.title(\"Autocorrelation TX2\")\nplt.xlim((-64, 63))\nplt.ylim((0, top))\nplt.grid(True)\n```\n\n::: {.cell-output .cell-output-display}\n![Autocorrelation of TX1](qpsk-sync_files/figure-html/tx-correlation-output-1.png){#tx-correlation width=1271 height=376 fig-align='center'}\n:::\n\nCorrelation between TX1 and TX2\n:::\n\n\nObserve the sharp auto-correlation peaks for each transmit signal. Also observe that the transmit signals' cross-correlation is very low; they don't correlate with each other well at all. This demonstrates that our signals have the properties we expected when we constructed them.\n\n# Communication Channel Simulation\nOur next step is to simulate the communication channel. We'll add a coarse (sample level) and fine (subsample level) delay to TX2. We'll then sum the two signals together. Finally, we'll add some additive white gaussian noise (AWGN).\nWe can also simulate mulitipath effects by passing the channel through a special sort of filter that emulates the effect of our signal being delayed by bouncing around and not taking a straight line path.\nAgain, a great resource is PySDR.org which has a section on [multipath fading](https://pysdr.org/content/multipath_fading.html).\nAs the signals \nBoth our Tx signals don't necessarily have to take the same path to get to the receiver either, making it even harder to imagine what the delays and attenuations both signals went through to get to the Rx1.\nFor now let's assume we have no fading as our channel stays constant through time (meaning the environment throgh which our signals propagate remains unchanging.) Otherwise, we would also have to account for a signal to noise ratio that changes with time as either our Tx's, our Rx, or our environment changes.\n\nTo keep things uncomplicated, let's just model our channel impulse response as something simple that will still account for the delays and attenuation from our signal going outside our line of sight.\n\n::: {#8037311a .cell execution_count=10}\n``` {.python .cell-code code-fold=\"false\"}\ndef apply_fractional_delay(s, delay=0.4):\n    # Create and apply fractional delay filter\n    # delay is fractional delay, in samples\n    N = 23\n    n = np.arange(-N // 2, N // 2)\n    h = np.sinc(n - delay)\n    h *= np.hamming(N)  # Window the filter to avoid edge artifacts\n    h /= np.sum(h)  # Normalize\n    return np.convolve(s, h)\n\n\ndef apply_sample_delay(s, delay=1):\n    return np.concatenate((np.zeros(delay), s))\n\n\ndef apply_frequency_offset(s, fo=13e3):\n    # Simulate a frequency offset (fo)\n    Ts = 1 / Fs  # Sample period\n    t = np.linspace(0, Ts * len(s), len(s))\n    return s * np.exp(1j * 2 * np.pi * fo * t)  # Shift frequency by fo\n\n\ndef apply_noise(s, level=0.3):\n    # Simulate adding AWGN\n    N = len(s)  # Number of samples\n    n = (np.random.randn(N) + 1j * np.random.randn(N)) / np.sqrt(2)\n    return s + n * level\n\n\ndef apply_channel_multipath(s):\n    # Multipath for a channel using randomly selected values for attenuation and delay.\n    # A better analysis would incorporate Rayleigh or Rician fading.\n    # This is only a first approximation.\n    h = np.array([1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0.12, 0, 0, 0.001])\n    return np.convolve(s, h)\n\n\n# Note: We extend the TX1 signal by the delay amount, so that we can later sum the TX signals when simulating\n# our receive channel.\ndelay = 2\ntx1d = np.append(tx1, np.zeros(delay))\ntx2d = apply_sample_delay(tx2, delay)\n\n# Note: We apply fractional delay to both TX signals as we want to delay both equally by the filter length.\n# Without this, TX2 would seem to arrive much later than TX1.\ntx1d = apply_fractional_delay(tx1d, 0)\ntx2d = apply_fractional_delay(tx2d, 0.5)\n\nrx1 = (tx1d + tx2d) / np.sqrt(2)\n\n# Note: Even a relatively small frequency offset confuses the correlation process we use\n# to measure when we received the signal. For example, with a sample rate of 20 MHz, an offset\n# of 13 kHz causes us to be unable to see clear correlation spikes for the two TX signals,\n# but we can still see clear # peaks with a smaller offset of 500 Hz. Perhaps other waveforms\n# than \"random QPSK\" would survive larger offsets better.\nrx1 = apply_frequency_offset(rx1, 0)\n```\n:::\n\n\n## Analysis\nNow, we'll analyze the received data. First, we'll filter the received data with the RRC filter composed previously, giving the overall communication channel an RC response and minimizing ISI. Second, we resample the received data; this allows us to observe properties of the received signal with subsample precision. Finally, we cross-correlate the received signals with each transmit signal; this shows us where the transmitted signals are within the receive data. We should see any delay we added here by observing the distance between cross-correlation peaks.\n\n\nSo what does our signal look like after passing through the channel?\n\n::: {#signal-at-rx .cell execution_count=11}\n``` {.python .cell-code code-fold=\"true\"}\nfig = plt.figure()\nplt.plot(rx1[100:250], '-')\nplt.ylabel(\"Magnitude\")\nplt.xlabel(\"Time\")\nplt.title(\"Signal with just delays and frequency offset\")\nplt.show()\n\nfig = plt.figure()\nplt.stem(apply_channel_multipath(np.array([1])), '.')\nplt.ylabel(\"Magnitude\")\nplt.xlabel(\"Time\")\nplt.title(\"Channel impulse response\")\nplt.show()\n\nfig = plt.figure()\nplt.plot(apply_channel_multipath(rx1[100:250]), '-')\nplt.ylabel(\"Magnitude\")\nplt.xlabel(\"Time\")\nplt.title(\"Signal with delays, frequency offset AND multichannel\")\nplt.show()\n\nrx1 = apply_noise(rx1)\nfig = plt.figure()\nplt.plot(apply_channel_multipath(rx1[100:250]), '-')\nplt.ylabel(\"Magnitude\")\nplt.xlabel(\"Time\")\nplt.title(\"Signal with delays, frequency offset, mulitipath AND noise\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Signal with just delays and frequency offset](qpsk-sync_files/figure-html/signal-at-rx-output-1.png){#signal-at-rx-1 width=600 height=449 fig-align='center'}\n:::\n\n::: {.cell-output .cell-output-display}\n![Channel impulse response](qpsk-sync_files/figure-html/signal-at-rx-output-2.png){#signal-at-rx-2 width=589 height=449 fig-align='center'}\n:::\n\n::: {.cell-output .cell-output-display}\n![Signal also modelling multipath](qpsk-sync_files/figure-html/signal-at-rx-output-3.png){#signal-at-rx-3 width=600 height=449 fig-align='center'}\n:::\n\n::: {.cell-output .cell-output-display}\n![Signal with delays, frequency offset, multipath, and channel noise](qpsk-sync_files/figure-html/signal-at-rx-output-4.png){#signal-at-rx-4 width=608 height=449 fig-align='center'}\n:::\n\nSignal at receiver\n:::\n\n\nWow\n\n![...](https://media1.tenor.com/m/DATRxbxadaoAAAAC/a-lot-of-damage.gif \"that's a lotta damage\")\n\n::: {#c7f5c0d5 .cell execution_count=12}\n``` {.python .cell-code code-fold=\"false\"}\n# Now that our channel is simulated, complete with signal and noise, let's filter at the receive end\n# with our RRC filter. This will make the end-to-end channel response that of a raised cosine filter,\n# which is good for minimizing ISI.\nrx1 = signal.convolve(rx1, pulse)\n```\n:::\n\n\n::: {#94cc4f6b .cell execution_count=13}\n``` {.python .cell-code code-fold=\"false\"}\n# Interpolate signal, so we can correlate with sub-sample accuracy\nRS = 10  # Increase signal length by RS times (e.g. 10x for RS 10)\nrx1i = signal.resample(rx1, np.shape(rx1)[0] * RS)\n\n# We also need to interpolate the TX signals for comparison\ntx1i = signal.resample(tx1, np.shape(tx1)[0] * RS)\ntx2i = signal.resample(tx2, np.shape(tx2)[0] * RS)\n```\n:::\n\n\n::: {#cell-Interpolating-Signal .cell execution_count=14}\n``` {.python .cell-code code-fold=\"true\"}\nNd = RS  # Number of samples to display\n\nplt.figure(figsize=(16, 4))\nplt.subplot(131)\nplt.plot(np.abs(rx1[:Nd]), \"bx-\")\nplt.ylabel(\"Value\")\nplt.title(\"Before interpolation\")\nplt.grid(True)\n\nplt.subplot(132)\nplt.plot(np.abs(rx1i[: Nd * RS - Nd]), \"bx-\")\nplt.xlabel(\"Value\")\nplt.title(\"After interpolation\")\nplt.grid(True)\n```\n\n::: {.cell-output .cell-output-display}\n![Autocorrelation of TX1](qpsk-sync_files/figure-html/interpolating-signal-output-1.png){#interpolating-signal width=855 height=376 fig-align='center'}\n:::\n\nInterpolating a signal to 'see' with sub-sample accuracy\n:::\n\n\nNow let's use the crosscorrelation to see the delay between the transmitted and received signals.\n\n::: {#interpolated-sample-delays .cell execution_count=15}\n``` {.python .cell-code code-fold=\"false\"}\nrtx1 = np.abs(signal.correlate(rx1i, tx1i, \"valid\"))\nrtx2 = np.abs(signal.correlate(rx1i, tx2i, \"valid\"))\nplt.figure(figsize=(12, 4))\nplt.plot(rtx1[: 100 * RS], \"r.-\")\nmax_tx1 = np.argmax(rtx1[: 100 * RS])\nplt.axvline(x=max_tx1, color='r')\nplt.text(max_tx1 + 3,  34500, f\"Delay of {max_tx1} samples.\", fontweight='bold')\nplt.plot(rtx2[: 100 * RS], \".-\")\nmax_tx2 = np.argmax(rtx2[: 100 * RS])\nplt.axvline(x=max_tx2, color='b')\nplt.text(max_tx2 + 3,  36500, f\"Delay of {max_tx2} samples.\", fontweight='bold')\nplt.grid(True)\nplt.xlabel(\"Interpolated sample number\")\nplt.ylabel(\"Correlation value\")\nplt.legend((\"TX1\", \"TX2\"))\nplt.title(\"Location of received TX signals\")\n```\n\n::: {#interpolated-sample-delays-1 .cell-output .cell-output-display execution_count=47}\n```\nText(0.5, 1.0, 'Location of received TX signals')\n```\n\nAutocorrelation of TX1\n:::\n\n::: {.cell-output .cell-output-display}\n![Autocorrelation of TX2](qpsk-sync_files/figure-html/interpolated-sample-delays-output-2.png){#interpolated-sample-delays-2 width=982 height=376 fig-align='center'}\n:::\n\nInterpolated sample delays between Rx and Tx channels\n:::\n\n\nObserve that our delays are in the interpolated sample scale (so we can do sub-sample estimation with any amount of accuracy). Once we obtain these numbers we go back to our actual samples which are a factor of `RS` smaller.\n\n::: {#6a934268 .cell execution_count=16}\n``` {.python .cell-code}\ntxdelay = (max_tx2 - max_tx1) / RS\n\nprint(f\"TX2 is behind TX1 by {txdelay:4f} samples\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTX2 is behind TX1 by 2.500000 samples\n```\n:::\n:::\n\n\n# Results\nWe see that the TX2 signal was delayed by approximately 2.5 samples relative to TX1, as intended. Our coarse (per sample) and fine (subsample) delays applied when simulating our communication channel are visible in the plot as the difference in interpolated samples between the two correlation peaks.\n\n",
    "supporting": [
      "qpsk-sync_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}