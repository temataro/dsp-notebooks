<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="github.com/{patater, temataro}">

<title>QPSK-Sync</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="qpsk-sync_files/libs/clipboard/clipboard.min.js"></script>
<script src="qpsk-sync_files/libs/quarto-html/quarto.js"></script>
<script src="qpsk-sync_files/libs/quarto-html/popper.min.js"></script>
<script src="qpsk-sync_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="qpsk-sync_files/libs/quarto-html/anchor.min.js"></script>
<link href="qpsk-sync_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="qpsk-sync_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="qpsk-sync_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="qpsk-sync_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="qpsk-sync_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#measuring-the-delay-between-two-qpsk-signals" id="toc-measuring-the-delay-between-two-qpsk-signals" class="nav-link active" data-scroll-target="#measuring-the-delay-between-two-qpsk-signals"><span class="header-section-number">1</span> Measuring the delay between two QPSK signals</a>
  <ul class="collapse">
  <li><a href="#the-transmit-signals-tx1-and-tx2" id="toc-the-transmit-signals-tx1-and-tx2" class="nav-link" data-scroll-target="#the-transmit-signals-tx1-and-tx2"><span class="header-section-number">1.1</span> The transmit signals (TX1 and TX2)</a></li>
  <li><a href="#pulse-shaping-our-data" id="toc-pulse-shaping-our-data" class="nav-link" data-scroll-target="#pulse-shaping-our-data"><span class="header-section-number">1.2</span> Pulse Shaping Our Data</a></li>
  </ul></li>
  <li><a href="#communication-channel-simulation" id="toc-communication-channel-simulation" class="nav-link" data-scroll-target="#communication-channel-simulation"><span class="header-section-number">2</span> Communication Channel Simulation</a>
  <ul class="collapse">
  <li><a href="#analysis" id="toc-analysis" class="nav-link" data-scroll-target="#analysis"><span class="header-section-number">2.1</span> Analysis</a></li>
  </ul></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results"><span class="header-section-number">3</span> Results</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">QPSK-Sync</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>github.com/{patater, temataro} </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="measuring-the-delay-between-two-qpsk-signals" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Measuring the delay between two QPSK signals</h1>
<div id="50cb4951" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> signal</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In this notebook, we’ll create and send two overlapping pseudo-random QPSK signals over a noisy reception channel. We’ll delay one of the signals relative to the other when simulating transmission. We’ll recover this delay, with sub-sample accuracy, using correlation and measuring the distance between the peaks.</p>
<section id="the-transmit-signals-tx1-and-tx2" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="the-transmit-signals-tx1-and-tx2"><span class="header-section-number">1.1</span> The transmit signals (TX1 and TX2)</h2>
<div id="f1da97c2" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>Fs   <span class="op">=</span> <span class="fl">20e6</span>             <span class="co"># 20 MHz sample rate</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>SPS  <span class="op">=</span> <span class="dv">4</span>                <span class="co"># Samples per symbol</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>Taps <span class="op">=</span> <span class="dv">61</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rc_filter(taps, beta<span class="op">=</span><span class="fl">0.33</span>):</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    Ts <span class="op">=</span> SPS</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    t  <span class="op">=</span> np.arange(taps)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    t <span class="op">-=</span> (taps <span class="op">-</span> <span class="dv">1</span>) <span class="op">//</span> <span class="dv">2</span>  <span class="co"># Center the indices around 0</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    h  <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> Ts</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    h <span class="op">*=</span> np.sinc(t <span class="op">/</span> Ts)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    h <span class="op">*=</span> np.cos(np.pi <span class="op">*</span> beta <span class="op">*</span> t <span class="op">/</span> Ts)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    h <span class="op">/=</span> <span class="fl">1.0</span> <span class="op">-</span> (<span class="fl">2.0</span> <span class="op">*</span> beta <span class="op">*</span> t <span class="op">/</span> Ts) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> h <span class="op">*</span> np.sqrt(Taps)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rrc_filter(taps, beta<span class="op">=</span><span class="fl">0.33</span>):</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create an RC filter</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    hrc <span class="op">=</span> rc_filter(taps, beta)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Take the square root of the RC filter in the frequency domain to obtain the frequency response of the</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># desired root raised cosine (RRC) filter.</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    Hrc <span class="op">=</span> np.fft.fft(hrc)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    Hrrc <span class="op">=</span> np.sqrt(np.<span class="bu">abs</span>(Hrc))</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Perform an IFFT to obtain the impulse reponse. Optionally, we could use the frequency response directly</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># and avoid the more expensive convolution operation to apply the filter (as multiplying in the frequency</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># domain is equivalent to convolution in the time domain)</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    hrrc <span class="op">=</span> np.fft.fftshift(np.fft.ifft(Hrrc))</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hrrc.real</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Why RRCs? Why not simple low pass filters?
</div>
</div>
<div class="callout-body-container callout-body">
<p>Create and use a root raised cosine filter so that when the receiver also uses an RRC filter, the complete, end-to-end channel response is thatof a raised cosine filter, which is pretty good at minimizing inter-symbol interference (ISI).</p>
</div>
</div>
<div class="cell" data-layout-nrow="2" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>pulse <span class="op">=</span> rrc_filter(taps<span class="op">=</span>Taps)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.arange(pulse.shape[<span class="dv">0</span>]) <span class="op">-</span> (pulse.shape[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>sp <span class="op">=</span> np.fft.fftshift(np.fft.fft(pulse))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>freq <span class="op">=</span> np.fft.fftshift(np.fft.fftfreq(t.shape[<span class="dv">0</span>]))</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>plt.plot(t, pulse, <span class="st">".-"</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Magnitude"</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Impulse Response (Time Domain)"</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>plt.plot(freq, np.<span class="bu">abs</span>(sp), <span class="st">".-"</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Magnitude"</span>)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Frequency Response"</span>)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-rrc" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-rrc-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="cell-output cell-output-display quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-rrc" style="flex-basis: 100.0%;justify-content: flex-start;">
<div id="fig-rrc-1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-rrc-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="qpsk-sync_files/figure-html/fig-rrc-output-1.png" data-ref-parent="fig-rrc" width="589" height="431" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-rrc-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) RC filter, beta=0.33
</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="cell-output cell-output-display quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-rrc" style="flex-basis: 100.0%;justify-content: flex-start;">
<div id="fig-rrc-2" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-rrc-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="qpsk-sync_files/figure-html/fig-rrc-output-2.png" data-ref-parent="fig-rrc" width="589" height="431" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-rrc-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) RRC filter, beta=0.33
</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-rrc-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: 61 Tap RC and RRC Filter Magnitude Response
</figcaption>
</figure>
</div>
</div>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Caution
</div>
</div>
<div class="callout-body-container callout-body">
<p>As a sidenote, observe that the units for the frequency response’s x-axis aren’t immediately obvious. (The time domain obviously has units in Ts where Ts is the sampling period.) When ‘digitizing’ an analog signal one must sample it leading to an implied assumption that everything happening before and after the samples were taken will repeat (the signal is periodic with period N). From this assumption, we get the digital frequency of the signal repeating (or in more technical terms, aliasing) around every 2<span class="math inline">\(\pi\)</span> radians.</p>
<p>Our frequency response (obtained by the DFT of the time domain signal) only extends between -<span class="math inline">\(\frac{\pi}{2}\)</span> and <span class="math inline">\(\frac{\pi}{2}\)</span>. To convert these into analog frequencies between <span class="math inline">\(\frac{-f_s}{2}\)</span> and <span class="math inline">\(\frac{f_s}{2}\)</span> use the formula: <span class="math display">\[\Omega = 2\pi * \frac{f}{f_s} \]</span></p>
</div>
</div>
<p>Let’s geneate our complex pseudo-random sequences (pulse trains). The longer the sequence we create, the more confident we can be at the receiver end which TX signal we are seeing and when.</p>
<div id="d2e61ad7" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>Ns  <span class="op">=</span> <span class="dv">2000</span>       <span class="co"># Number of symbols to generate</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>N   <span class="op">=</span> Ns <span class="op">*</span> SPS   <span class="co"># Number of samples</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>BPS <span class="op">=</span> <span class="dv">2</span>          <span class="co"># QPSK has 2 bits per symbol</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>Nd  <span class="op">=</span> <span class="dv">23</span>         <span class="co"># Number of symbols to display</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gen_pulse_train():</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    sym <span class="op">=</span> np.random.randint(<span class="dv">0</span>, BPS<span class="op">**</span><span class="dv">2</span>, Ns)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> np.zeros(N, dtype<span class="op">=</span><span class="bu">complex</span>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, ss <span class="kw">in</span> <span class="bu">enumerate</span>(sym):</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        s[i <span class="op">*</span> SPS] <span class="op">+=</span> (ss <span class="op">&amp;</span> <span class="bn">0b01</span>) <span class="op">-</span> <span class="fl">0.5</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        s[i <span class="op">*</span> SPS] <span class="op">+=</span> <span class="ot">1j</span> <span class="op">*</span> (((ss <span class="op">&amp;</span> <span class="bn">0b10</span>) <span class="op">&gt;&gt;</span> <span class="dv">1</span>) <span class="op">-</span> <span class="fl">0.5</span>)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="random-bits" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> gen_pulse_train()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> gen_pulse_train()</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(x), <span class="st">"r.-"</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>plt.plot(np.imag(x), <span class="st">".-"</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Value"</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Impulse train X"</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>plt.xlim((<span class="dv">0</span>, Nd))</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>plt.ylim((<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>Oversampling <span class="op">=</span> <span class="dv">25</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>plt.plot(np.repeat(np.real(x), Oversampling), <span class="st">"r.-"</span>)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>plt.plot(np.repeat(np.imag(x), Oversampling), <span class="st">".-"</span>)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Value"</span>)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Oversampled Impulse train X"</span>)</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>plt.xlim((<span class="dv">0</span>, Oversampling <span class="op">*</span> Nd))</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>plt.ylim((<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(y), <span class="st">"r.-"</span>)</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>plt.plot(np.imag(y), <span class="st">".-"</span>)</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Value"</span>)</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Impulse train Y"</span>)</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>plt.xlim((<span class="dv">0</span>, Nd))</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>plt.ylim((<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>plt.plot(np.repeat(np.real(y), Oversampling), <span class="st">"r.-"</span>)</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>plt.plot(np.repeat(np.imag(y), Oversampling), <span class="st">".-"</span>)</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Value"</span>)</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Oversampled Impulse train Y"</span>)</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>plt.xlim((<span class="dv">0</span>, Oversampling <span class="op">*</span> Nd))</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>plt.ylim((<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qpsk-sync_files/figure-html/random-bits-output-1.png" class="quarto-figure quarto-figure-center figure-img" width="608" height="431"></p>
<figcaption>Impulse Train X</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qpsk-sync_files/figure-html/random-bits-output-2.png" class="quarto-figure quarto-figure-center figure-img" width="608" height="431"></p>
<figcaption>Impulse Train X Oversampled by 20 to see bits better</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qpsk-sync_files/figure-html/random-bits-output-3.png" class="quarto-figure quarto-figure-center figure-img" width="608" height="431"></p>
<figcaption>Impulse Train Y</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qpsk-sync_files/figure-html/random-bits-output-4.png" class="quarto-figure quarto-figure-center figure-img" width="608" height="431"></p>
<figcaption>Impulse Train Y Oversampled by 20 to see bits better</figcaption>
</figure>
</div>
</div>
<p>Generated Random Impulse Trains</p>
</div>
<section id="interlude-representing-qpsk-data" class="level4" data-number="1.1.0.1">
<h4 data-number="1.1.0.1" class="anchored" data-anchor-id="interlude-representing-qpsk-data"><span class="header-section-number">1.1.0.1</span> Interlude: Representing QPSK data</h4>
<p>For QPSK we have 4 symbols that we would like to represent as IQ data. Therefore, we need a mapping from the linear {0b00, 0b01, 0b10, 0b11} to a complex {(-0.5 - j<em>0.5), (0.5 - j</em>0.5), (-0.5 + j<em>0.5), (0.5 + j</em>0.5)}</p>
<div id="cell-QPSK" class="cell" data-execution_count="6">
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qpsk-sync_files/figure-html/qpsk-output-1.png" class="quarto-figure quarto-figure-center figure-img" width="623" height="449"></p>
<figcaption>QPSK Constellation Diagram</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="pulse-shaping-our-data" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="pulse-shaping-our-data"><span class="header-section-number">1.2</span> Pulse Shaping Our Data</h2>
<div id="pulse-shaping" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>tx1 <span class="op">=</span> signal.convolve(x, pulse)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>tx2 <span class="op">=</span> signal.convolve(y, pulse)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Convolution has the effect of making our signal a bit longer (N + Taps/2 - 1)</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.arange(tx1.shape[<span class="dv">0</span>])</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(tx1), <span class="st">"r.-"</span>, np.imag(tx1), <span class="st">".-"</span>)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Value"</span>)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"TX1"</span>)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>plt.xlim((Taps<span class="op">//</span><span class="dv">2</span>, SPS <span class="op">*</span> Nd))</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(tx2), <span class="st">"r.-"</span>, np.imag(tx2), <span class="st">".-"</span>)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Value"</span>)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"TX2"</span>)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>plt.xlim((Taps<span class="op">//</span><span class="dv">2</span>, SPS <span class="op">*</span> Nd))</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qpsk-sync_files/figure-html/pulse-shaping-output-1.png" class="quarto-figure quarto-figure-center figure-img" width="600" height="431"></p>
<figcaption>Pulse shaped TX1</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qpsk-sync_files/figure-html/pulse-shaping-output-2.png" class="quarto-figure quarto-figure-center figure-img" width="600" height="431"></p>
<figcaption>Pulse shaped TX2</figcaption>
</figure>
</div>
</div>
<p>Pulse shaped bits to be transmitted</p>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>What we see above are signals that are more resilient to inter-symbol interference due to the RRC filter we applied on both ends of our chain. A lowpass filter is applied before and after transmission to reduce the spectrum usage of our signal (and for noise resilience). A great article on the topic by Dr.&nbsp;Marc Lichtman can be found on <a href="https://pysdr.org/content/pulse_shaping.html">PySDR.org</a>.</p>
</div>
</div>
<div id="tx-iq-data" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>IQd <span class="op">=</span> <span class="dv">500</span>  <span class="co"># Raw IQ Samples to display</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"TX1 IQ Constellation"</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Quadrature"</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"In-phase"</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>plt.ylim((<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>plt.xlim((<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(tx1[Taps<span class="op">//</span><span class="dv">2</span>:IQd:SPS]), np.imag(tx1[Taps<span class="op">//</span><span class="dv">2</span>:IQd:SPS]), <span class="st">"."</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(x[<span class="dv">0</span>::SPS]), np.imag(x[<span class="dv">0</span>::SPS]), <span class="st">"r."</span>)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"TX2 IQ Constellation"</span>)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Quadrature"</span>)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"In-phase"</span>)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>plt.ylim((<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>plt.xlim((<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(tx2[Taps<span class="op">//</span><span class="dv">2</span>:IQd:SPS]), np.imag(tx2[Taps<span class="op">//</span><span class="dv">2</span>:IQd:SPS]), <span class="st">"."</span>)</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(y[<span class="dv">0</span>::SPS]), np.imag(y[<span class="dv">0</span>::SPS]), <span class="st">"r."</span>)</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qpsk-sync_files/figure-html/tx-iq-data-output-1.png" class="quarto-figure quarto-figure-center figure-img" width="623" height="449"></p>
<figcaption>IQ constellation for TX1</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qpsk-sync_files/figure-html/tx-iq-data-output-2.png" class="quarto-figure quarto-figure-center figure-img" width="623" height="449"></p>
<figcaption>IQ constellation for TX2</figcaption>
</figure>
</div>
</div>
<p>IQ samples of TX1 and TX2</p>
</div>
<p>From the IQ diagrams, we can see that the two transmission signals are both clean QPSK.</p>
<div id="cell-TX-Correlation" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>ac1 <span class="op">=</span> signal.correlate(tx1, tx1)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>ac2 <span class="op">=</span> signal.correlate(tx2, tx2)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>cc <span class="op">=</span> signal.correlate(tx1, tx2)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>ac1 <span class="op">=</span> signal.correlate(tx1, tx1)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>ac2 <span class="op">=</span> signal.correlate(tx2, tx2)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>cc <span class="op">=</span> signal.correlate(tx1, tx2)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.arange(ac1.shape[<span class="dv">0</span>]) <span class="op">-</span> (ac1.shape[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>top <span class="op">=</span> np.<span class="bu">max</span>((np.<span class="bu">abs</span>(ac1), np.<span class="bu">abs</span>(ac2), np.<span class="bu">abs</span>(cc)))</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">4</span>))</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">131</span>)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>plt.plot(t, np.<span class="bu">abs</span>(ac1), <span class="st">".-"</span>)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Correlation"</span>)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Autocorrelation TX1"</span>)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>plt.xlim((<span class="op">-</span><span class="dv">64</span>, <span class="dv">63</span>)) <span class="co"># Display the center 128 samples</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>plt.ylim((<span class="dv">0</span>, top))</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">132</span>)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>plt.plot(t, np.<span class="bu">abs</span>(cc), <span class="st">".-"</span>)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Lag"</span>)</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Crosscorrelation TX1:TX2"</span>)</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>plt.xlim((<span class="op">-</span><span class="dv">64</span>, <span class="dv">63</span>))</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>plt.ylim((<span class="dv">0</span>, top))</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">133</span>)</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>plt.plot(t, np.<span class="bu">abs</span>(ac2), <span class="st">".-"</span>)</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Autocorrelation TX2"</span>)</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>plt.xlim((<span class="op">-</span><span class="dv">64</span>, <span class="dv">63</span>))</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>plt.ylim((<span class="dv">0</span>, top))</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qpsk-sync_files/figure-html/tx-correlation-output-1.png" class="quarto-figure quarto-figure-center figure-img" width="1271" height="376"></p>
<figcaption>Autocorrelation of TX1</figcaption>
</figure>
</div>
</div>
<p>Correlation between TX1 and TX2</p>
</div>
<p>Observe the sharp auto-correlation peaks for each transmit signal. Also observe that the transmit signals’ cross-correlation is very low; they don’t correlate with each other well at all. This demonstrates that our signals have the properties we expected when we constructed them.</p>
</section>
</section>
<section id="communication-channel-simulation" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Communication Channel Simulation</h1>
<p>Our next step is to simulate the communication channel. We’ll add a coarse (sample level) and fine (subsample level) delay to TX2. We’ll then sum the two signals together. Finally, we’ll add some additive white gaussian noise (AWGN). We can also simulate mulitipath effects by passing the channel through a special sort of filter that emulates the effect of our signal being delayed by bouncing around and not taking a straight line path. Again, a great resource is PySDR.org which has a section on <a href="https://pysdr.org/content/multipath_fading.html">multipath fading</a>. As the signals Both our Tx signals don’t necessarily have to take the same path to get to the receiver either, making it even harder to imagine what the delays and attenuations both signals went through to get to the Rx1. For now let’s assume we have no fading as our channel stays constant through time (meaning the environment throgh which our signals propagate remains unchanging.) Otherwise, we would also have to account for a signal to noise ratio that changes with time as either our Tx’s, our Rx, or our environment changes.</p>
<p>To keep things uncomplicated, let’s just model our channel impulse response as something simple that will still account for the delays and attenuation from our signal going outside our line of sight.</p>
<div id="8037311a" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> apply_fractional_delay(s, delay<span class="op">=</span><span class="fl">0.4</span>):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create and apply fractional delay filter</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># delay is fractional delay, in samples</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="dv">23</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> np.arange(<span class="op">-</span>N <span class="op">//</span> <span class="dv">2</span>, N <span class="op">//</span> <span class="dv">2</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> np.sinc(n <span class="op">-</span> delay)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    h <span class="op">*=</span> np.hamming(N)  <span class="co"># Window the filter to avoid edge artifacts</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    h <span class="op">/=</span> np.<span class="bu">sum</span>(h)  <span class="co"># Normalize</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.convolve(s, h)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> apply_sample_delay(s, delay<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.concatenate((np.zeros(delay), s))</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> apply_frequency_offset(s, fo<span class="op">=</span><span class="fl">13e3</span>):</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simulate a frequency offset (fo)</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    Ts <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> Fs  <span class="co"># Sample period</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> np.linspace(<span class="dv">0</span>, Ts <span class="op">*</span> <span class="bu">len</span>(s), <span class="bu">len</span>(s))</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s <span class="op">*</span> np.exp(<span class="ot">1j</span> <span class="op">*</span> <span class="dv">2</span> <span class="op">*</span> np.pi <span class="op">*</span> fo <span class="op">*</span> t)  <span class="co"># Shift frequency by fo</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> apply_noise(s, level<span class="op">=</span><span class="fl">0.3</span>):</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simulate adding AWGN</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="bu">len</span>(s)  <span class="co"># Number of samples</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> (np.random.randn(N) <span class="op">+</span> <span class="ot">1j</span> <span class="op">*</span> np.random.randn(N)) <span class="op">/</span> np.sqrt(<span class="dv">2</span>)</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s <span class="op">+</span> n <span class="op">*</span> level</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> apply_channel_multipath(s):</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Multipath for a channel using randomly selected values for attenuation and delay.</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># A better analysis would incorporate Rayleigh or Rician fading.</span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This is only a first approximation.</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="fl">0.5</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="fl">0.12</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="fl">0.001</span>])</span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.convolve(s, h)</span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Note: We extend the TX1 signal by the delay amount, so that we can later sum the TX signals when simulating</span></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a><span class="co"># our receive channel.</span></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>delay <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>tx1d <span class="op">=</span> np.append(tx1, np.zeros(delay))</span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>tx2d <span class="op">=</span> apply_sample_delay(tx2, delay)</span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a><span class="co"># Note: We apply fractional delay to both TX signals as we want to delay both equally by the filter length.</span></span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Without this, TX2 would seem to arrive much later than TX1.</span></span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>tx1d <span class="op">=</span> apply_fractional_delay(tx1d, <span class="dv">0</span>)</span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>tx2d <span class="op">=</span> apply_fractional_delay(tx2d, <span class="fl">0.5</span>)</span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a>rx1 <span class="op">=</span> (tx1d <span class="op">+</span> tx2d) <span class="op">/</span> np.sqrt(<span class="dv">2</span>)</span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a><span class="co"># Note: Even a relatively small frequency offset confuses the correlation process we use</span></span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a><span class="co"># to measure when we received the signal. For example, with a sample rate of 20 MHz, an offset</span></span>
<span id="cb9-53"><a href="#cb9-53" aria-hidden="true" tabindex="-1"></a><span class="co"># of 13 kHz causes us to be unable to see clear correlation spikes for the two TX signals,</span></span>
<span id="cb9-54"><a href="#cb9-54" aria-hidden="true" tabindex="-1"></a><span class="co"># but we can still see clear # peaks with a smaller offset of 500 Hz. Perhaps other waveforms</span></span>
<span id="cb9-55"><a href="#cb9-55" aria-hidden="true" tabindex="-1"></a><span class="co"># than "random QPSK" would survive larger offsets better.</span></span>
<span id="cb9-56"><a href="#cb9-56" aria-hidden="true" tabindex="-1"></a>rx1 <span class="op">=</span> apply_frequency_offset(rx1, <span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="analysis" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="analysis"><span class="header-section-number">2.1</span> Analysis</h2>
<p>Now, we’ll analyze the received data. First, we’ll filter the received data with the RRC filter composed previously, giving the overall communication channel an RC response and minimizing ISI. Second, we resample the received data; this allows us to observe properties of the received signal with subsample precision. Finally, we cross-correlate the received signals with each transmit signal; this shows us where the transmitted signals are within the receive data. We should see any delay we added here by observing the distance between cross-correlation peaks.</p>
<p>So what does our signal look like after passing through the channel?</p>
<div id="signal-at-rx" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>plt.plot(rx1[<span class="dv">100</span>:<span class="dv">250</span>], <span class="st">'-'</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Magnitude"</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Time"</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Signal with just delays and frequency offset"</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>plt.stem(apply_channel_multipath(np.array([<span class="dv">1</span>])), <span class="st">'.'</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Magnitude"</span>)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Time"</span>)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Channel impulse response"</span>)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>plt.plot(apply_channel_multipath(rx1[<span class="dv">100</span>:<span class="dv">250</span>]), <span class="st">'-'</span>)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Magnitude"</span>)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Time"</span>)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Signal with delays, frequency offset AND multichannel"</span>)</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>rx1 <span class="op">=</span> apply_noise(rx1)</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>plt.plot(apply_channel_multipath(rx1[<span class="dv">100</span>:<span class="dv">250</span>]), <span class="st">'-'</span>)</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Magnitude"</span>)</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Time"</span>)</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Signal with delays, frequency offset, mulitipath AND noise"</span>)</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qpsk-sync_files/figure-html/signal-at-rx-output-1.png" class="quarto-figure quarto-figure-center figure-img" width="600" height="449"></p>
<figcaption>Signal with just delays and frequency offset</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qpsk-sync_files/figure-html/signal-at-rx-output-2.png" class="quarto-figure quarto-figure-center figure-img" width="589" height="449"></p>
<figcaption>Channel impulse response</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qpsk-sync_files/figure-html/signal-at-rx-output-3.png" class="quarto-figure quarto-figure-center figure-img" width="600" height="449"></p>
<figcaption>Signal also modelling multipath</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qpsk-sync_files/figure-html/signal-at-rx-output-4.png" class="quarto-figure quarto-figure-center figure-img" width="608" height="449"></p>
<figcaption>Signal with delays, frequency offset, multipath, and channel noise</figcaption>
</figure>
</div>
</div>
<p>Signal at receiver</p>
</div>
<p>Wow</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://media1.tenor.com/m/DATRxbxadaoAAAAC/a-lot-of-damage.gif" title="that's a lotta damage" class="img-fluid figure-img"></p>
<figcaption>…</figcaption>
</figure>
</div>
<div id="c7f5c0d5" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Now that our channel is simulated, complete with signal and noise, let's filter at the receive end</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co"># with our RRC filter. This will make the end-to-end channel response that of a raised cosine filter,</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co"># which is good for minimizing ISI.</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>rx1 <span class="op">=</span> signal.convolve(rx1, pulse)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="94cc4f6b" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Interpolate signal, so we can correlate with sub-sample accuracy</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>RS <span class="op">=</span> <span class="dv">10</span>  <span class="co"># Increase signal length by RS times (e.g. 10x for RS 10)</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>rx1i <span class="op">=</span> signal.resample(rx1, np.shape(rx1)[<span class="dv">0</span>] <span class="op">*</span> RS)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co"># We also need to interpolate the TX signals for comparison</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>tx1i <span class="op">=</span> signal.resample(tx1, np.shape(tx1)[<span class="dv">0</span>] <span class="op">*</span> RS)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>tx2i <span class="op">=</span> signal.resample(tx2, np.shape(tx2)[<span class="dv">0</span>] <span class="op">*</span> RS)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-Interpolating-Signal" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>Nd <span class="op">=</span> RS  <span class="co"># Number of samples to display</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">4</span>))</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">131</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>plt.plot(np.<span class="bu">abs</span>(rx1[:Nd]), <span class="st">"bx-"</span>)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Value"</span>)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Before interpolation"</span>)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">132</span>)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>plt.plot(np.<span class="bu">abs</span>(rx1i[: Nd <span class="op">*</span> RS <span class="op">-</span> Nd]), <span class="st">"bx-"</span>)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Value"</span>)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"After interpolation"</span>)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qpsk-sync_files/figure-html/interpolating-signal-output-1.png" class="quarto-figure quarto-figure-center figure-img" width="855" height="376"></p>
<figcaption>Autocorrelation of TX1</figcaption>
</figure>
</div>
</div>
<p>Interpolating a signal to ‘see’ with sub-sample accuracy</p>
</div>
<p>Now let’s use the crosscorrelation to see the delay between the transmitted and received signals.</p>
<div id="interpolated-sample-delays" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>rtx1 <span class="op">=</span> np.<span class="bu">abs</span>(signal.correlate(rx1i, tx1i, <span class="st">"valid"</span>))</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>rtx2 <span class="op">=</span> np.<span class="bu">abs</span>(signal.correlate(rx1i, tx2i, <span class="st">"valid"</span>))</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>))</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>plt.plot(rtx1[: <span class="dv">100</span> <span class="op">*</span> RS], <span class="st">"r.-"</span>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>max_tx1 <span class="op">=</span> np.argmax(rtx1[: <span class="dv">100</span> <span class="op">*</span> RS])</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>plt.axvline(x<span class="op">=</span>max_tx1, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>plt.text(max_tx1 <span class="op">+</span> <span class="dv">3</span>,  <span class="dv">34500</span>, <span class="ss">f"Delay of </span><span class="sc">{</span>max_tx1<span class="sc">}</span><span class="ss"> samples."</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>plt.plot(rtx2[: <span class="dv">100</span> <span class="op">*</span> RS], <span class="st">".-"</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>max_tx2 <span class="op">=</span> np.argmax(rtx2[: <span class="dv">100</span> <span class="op">*</span> RS])</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>plt.axvline(x<span class="op">=</span>max_tx2, color<span class="op">=</span><span class="st">'b'</span>)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>plt.text(max_tx2 <span class="op">+</span> <span class="dv">3</span>,  <span class="dv">36500</span>, <span class="ss">f"Delay of </span><span class="sc">{</span>max_tx2<span class="sc">}</span><span class="ss"> samples."</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Interpolated sample number"</span>)</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Correlation value"</span>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>plt.legend((<span class="st">"TX1"</span>, <span class="st">"TX2"</span>))</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Location of received TX signals"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="interpolated-sample-delays-1" class="cell-output cell-output-display" data-execution_count="47">
<pre><code>Text(0.5, 1.0, 'Location of received TX signals')</code></pre>
<p>Autocorrelation of TX1</p>
</div>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qpsk-sync_files/figure-html/interpolated-sample-delays-output-2.png" class="quarto-figure quarto-figure-center figure-img" width="982" height="376"></p>
<figcaption>Autocorrelation of TX2</figcaption>
</figure>
</div>
</div>
<p>Interpolated sample delays between Rx and Tx channels</p>
</div>
<p>Observe that our delays are in the interpolated sample scale (so we can do sub-sample estimation with any amount of accuracy). Once we obtain these numbers we go back to our actual samples which are a factor of <code>RS</code> smaller.</p>
<div id="6a934268" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>txdelay <span class="op">=</span> (max_tx2 <span class="op">-</span> max_tx1) <span class="op">/</span> RS</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"TX2 is behind TX1 by </span><span class="sc">{</span>txdelay<span class="sc">:4f}</span><span class="ss"> samples"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>TX2 is behind TX1 by 2.500000 samples</code></pre>
</div>
</div>
</section>
</section>
<section id="results" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Results</h1>
<p>We see that the TX2 signal was delayed by approximately 2.5 samples relative to TX1, as intended. Our coarse (per sample) and fine (subsample) delays applied when simulating our communication channel are visible in the plot as the difference in interpolated samples between the two correlation peaks.</p>
<!-- -->

</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb18" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> QPSK-Sync</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="an">theme:</span><span class="co"> "cerulean"</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co"># https://quarto.org/docs/dashboards/theming.html</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="an">highlight-style:</span><span class="co"> github</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span><span class="co"> github.com/{patater, temataro}</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="an">toc:</span><span class="co">              true</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="an">number-sections:</span><span class="co">  true</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="co">  html:</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="co">    code-fold:    false</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="co">    code-tools:   true</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span class="fu"># Measuring the delay between two QPSK signals</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> signal</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>In this notebook, we'll create and send two overlapping pseudo-random QPSK signals over a noisy reception channel. We'll delay one of the signals relative to the other when simulating transmission. We'll recover this delay, with sub-sample accuracy, using correlation and measuring the distance between the peaks.</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a><span class="fu">## The transmit signals (TX1 and TX2)</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>Fs   <span class="op">=</span> <span class="fl">20e6</span>             <span class="co"># 20 MHz sample rate</span></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>SPS  <span class="op">=</span> <span class="dv">4</span>                <span class="co"># Samples per symbol</span></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>Taps <span class="op">=</span> <span class="dv">61</span></span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rc_filter(taps, beta<span class="op">=</span><span class="fl">0.33</span>):</span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>    Ts <span class="op">=</span> SPS</span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>    t  <span class="op">=</span> np.arange(taps)</span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>    t <span class="op">-=</span> (taps <span class="op">-</span> <span class="dv">1</span>) <span class="op">//</span> <span class="dv">2</span>  <span class="co"># Center the indices around 0</span></span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>    h  <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> Ts</span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a>    h <span class="op">*=</span> np.sinc(t <span class="op">/</span> Ts)</span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>    h <span class="op">*=</span> np.cos(np.pi <span class="op">*</span> beta <span class="op">*</span> t <span class="op">/</span> Ts)</span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>    h <span class="op">/=</span> <span class="fl">1.0</span> <span class="op">-</span> (<span class="fl">2.0</span> <span class="op">*</span> beta <span class="op">*</span> t <span class="op">/</span> Ts) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> h <span class="op">*</span> np.sqrt(Taps)</span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rrc_filter(taps, beta<span class="op">=</span><span class="fl">0.33</span>):</span>
<span id="cb18-45"><a href="#cb18-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create an RC filter</span></span>
<span id="cb18-46"><a href="#cb18-46" aria-hidden="true" tabindex="-1"></a>    hrc <span class="op">=</span> rc_filter(taps, beta)</span>
<span id="cb18-47"><a href="#cb18-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-48"><a href="#cb18-48" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Take the square root of the RC filter in the frequency domain to obtain the frequency response of the</span></span>
<span id="cb18-49"><a href="#cb18-49" aria-hidden="true" tabindex="-1"></a>    <span class="co"># desired root raised cosine (RRC) filter.</span></span>
<span id="cb18-50"><a href="#cb18-50" aria-hidden="true" tabindex="-1"></a>    Hrc <span class="op">=</span> np.fft.fft(hrc)</span>
<span id="cb18-51"><a href="#cb18-51" aria-hidden="true" tabindex="-1"></a>    Hrrc <span class="op">=</span> np.sqrt(np.<span class="bu">abs</span>(Hrc))</span>
<span id="cb18-52"><a href="#cb18-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-53"><a href="#cb18-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Perform an IFFT to obtain the impulse reponse. Optionally, we could use the frequency response directly</span></span>
<span id="cb18-54"><a href="#cb18-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># and avoid the more expensive convolution operation to apply the filter (as multiplying in the frequency</span></span>
<span id="cb18-55"><a href="#cb18-55" aria-hidden="true" tabindex="-1"></a>    <span class="co"># domain is equivalent to convolution in the time domain)</span></span>
<span id="cb18-56"><a href="#cb18-56" aria-hidden="true" tabindex="-1"></a>    hrrc <span class="op">=</span> np.fft.fftshift(np.fft.ifft(Hrrc))</span>
<span id="cb18-57"><a href="#cb18-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> hrrc.real</span>
<span id="cb18-58"><a href="#cb18-58" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb18-59"><a href="#cb18-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-60"><a href="#cb18-60" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb18-61"><a href="#cb18-61" aria-hidden="true" tabindex="-1"></a><span class="fu"># Why RRCs? Why not simple low pass filters?</span></span>
<span id="cb18-62"><a href="#cb18-62" aria-hidden="true" tabindex="-1"></a>Create and use a root raised cosine filter so that when the receiver also uses an RRC filter, the complete, end-to-end channel response is thatof a raised cosine filter, which is pretty good at minimizing inter-symbol interference (ISI).</span>
<span id="cb18-63"><a href="#cb18-63" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb18-66"><a href="#cb18-66" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb18-67"><a href="#cb18-67" aria-hidden="true" tabindex="-1"></a><span class="co">#| label:        fig-RRC</span></span>
<span id="cb18-68"><a href="#cb18-68" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap:      "61 Tap RC and RRC Filter Magnitude Response"</span></span>
<span id="cb18-69"><a href="#cb18-69" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-subcap:</span></span>
<span id="cb18-70"><a href="#cb18-70" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "RC filter, beta=0.33"</span></span>
<span id="cb18-71"><a href="#cb18-71" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "RRC filter, beta=0.33"</span></span>
<span id="cb18-72"><a href="#cb18-72" aria-hidden="true" tabindex="-1"></a><span class="co">#| layout-nrow:  2</span></span>
<span id="cb18-73"><a href="#cb18-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-74"><a href="#cb18-74" aria-hidden="true" tabindex="-1"></a>pulse <span class="op">=</span> rrc_filter(taps<span class="op">=</span>Taps)</span>
<span id="cb18-75"><a href="#cb18-75" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.arange(pulse.shape[<span class="dv">0</span>]) <span class="op">-</span> (pulse.shape[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb18-76"><a href="#cb18-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-77"><a href="#cb18-77" aria-hidden="true" tabindex="-1"></a>sp <span class="op">=</span> np.fft.fftshift(np.fft.fft(pulse))</span>
<span id="cb18-78"><a href="#cb18-78" aria-hidden="true" tabindex="-1"></a>freq <span class="op">=</span> np.fft.fftshift(np.fft.fftfreq(t.shape[<span class="dv">0</span>]))</span>
<span id="cb18-79"><a href="#cb18-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-80"><a href="#cb18-80" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb18-81"><a href="#cb18-81" aria-hidden="true" tabindex="-1"></a>plt.plot(t, pulse, <span class="st">".-"</span>)</span>
<span id="cb18-82"><a href="#cb18-82" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Magnitude"</span>)</span>
<span id="cb18-83"><a href="#cb18-83" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Impulse Response (Time Domain)"</span>)</span>
<span id="cb18-84"><a href="#cb18-84" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb18-85"><a href="#cb18-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-86"><a href="#cb18-86" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb18-87"><a href="#cb18-87" aria-hidden="true" tabindex="-1"></a>plt.plot(freq, np.<span class="bu">abs</span>(sp), <span class="st">".-"</span>)</span>
<span id="cb18-88"><a href="#cb18-88" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Magnitude"</span>)</span>
<span id="cb18-89"><a href="#cb18-89" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Frequency Response"</span>)</span>
<span id="cb18-90"><a href="#cb18-90" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb18-91"><a href="#cb18-91" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb18-92"><a href="#cb18-92" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb18-93"><a href="#cb18-93" aria-hidden="true" tabindex="-1"></a>:::{.callout-caution}</span>
<span id="cb18-94"><a href="#cb18-94" aria-hidden="true" tabindex="-1"></a>As a sidenote, observe that the units for the frequency response's x-axis aren't immediately obvious. (The time domain obviously has units in Ts where Ts is the sampling period.)</span>
<span id="cb18-95"><a href="#cb18-95" aria-hidden="true" tabindex="-1"></a>When 'digitizing' an analog signal one must sample it leading to an implied assumption that everything happening before and after the samples were taken will repeat (the signal is periodic with period N). From this assumption, we get the digital frequency of the signal repeating (or in more technical terms, aliasing) around every 2$\pi$ radians.</span>
<span id="cb18-96"><a href="#cb18-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-97"><a href="#cb18-97" aria-hidden="true" tabindex="-1"></a>Our frequency response (obtained by the DFT of the time domain signal) only extends between -$\frac{\pi}{2}$ and $\frac{\pi}{2}$.</span>
<span id="cb18-98"><a href="#cb18-98" aria-hidden="true" tabindex="-1"></a>To convert these into analog frequencies between $\frac{-f_s}{2}$ and $\frac{f_s}{2}$ use the formula:</span>
<span id="cb18-99"><a href="#cb18-99" aria-hidden="true" tabindex="-1"></a>$$\Omega = 2\pi * \frac{f}{f_s} $$</span>
<span id="cb18-100"><a href="#cb18-100" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb18-101"><a href="#cb18-101" aria-hidden="true" tabindex="-1"></a>Let's geneate our complex pseudo-random sequences (pulse trains).</span>
<span id="cb18-102"><a href="#cb18-102" aria-hidden="true" tabindex="-1"></a>The longer the sequence we create, the more confident we can be at the receiver end which TX signal we are seeing and when.</span>
<span id="cb18-103"><a href="#cb18-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-106"><a href="#cb18-106" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb18-107"><a href="#cb18-107" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb18-108"><a href="#cb18-108" aria-hidden="true" tabindex="-1"></a>Ns  <span class="op">=</span> <span class="dv">2000</span>       <span class="co"># Number of symbols to generate</span></span>
<span id="cb18-109"><a href="#cb18-109" aria-hidden="true" tabindex="-1"></a>N   <span class="op">=</span> Ns <span class="op">*</span> SPS   <span class="co"># Number of samples</span></span>
<span id="cb18-110"><a href="#cb18-110" aria-hidden="true" tabindex="-1"></a>BPS <span class="op">=</span> <span class="dv">2</span>          <span class="co"># QPSK has 2 bits per symbol</span></span>
<span id="cb18-111"><a href="#cb18-111" aria-hidden="true" tabindex="-1"></a>Nd  <span class="op">=</span> <span class="dv">23</span>         <span class="co"># Number of symbols to display</span></span>
<span id="cb18-112"><a href="#cb18-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-113"><a href="#cb18-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-114"><a href="#cb18-114" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gen_pulse_train():</span>
<span id="cb18-115"><a href="#cb18-115" aria-hidden="true" tabindex="-1"></a>    sym <span class="op">=</span> np.random.randint(<span class="dv">0</span>, BPS<span class="op">**</span><span class="dv">2</span>, Ns)</span>
<span id="cb18-116"><a href="#cb18-116" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> np.zeros(N, dtype<span class="op">=</span><span class="bu">complex</span>)</span>
<span id="cb18-117"><a href="#cb18-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-118"><a href="#cb18-118" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, ss <span class="kw">in</span> <span class="bu">enumerate</span>(sym):</span>
<span id="cb18-119"><a href="#cb18-119" aria-hidden="true" tabindex="-1"></a>        s[i <span class="op">*</span> SPS] <span class="op">+=</span> (ss <span class="op">&amp;</span> <span class="bn">0b01</span>) <span class="op">-</span> <span class="fl">0.5</span></span>
<span id="cb18-120"><a href="#cb18-120" aria-hidden="true" tabindex="-1"></a>        s[i <span class="op">*</span> SPS] <span class="op">+=</span> <span class="ot">1j</span> <span class="op">*</span> (((ss <span class="op">&amp;</span> <span class="bn">0b10</span>) <span class="op">&gt;&gt;</span> <span class="dv">1</span>) <span class="op">-</span> <span class="fl">0.5</span>)</span>
<span id="cb18-121"><a href="#cb18-121" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s</span>
<span id="cb18-122"><a href="#cb18-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-123"><a href="#cb18-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-124"><a href="#cb18-124" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb18-125"><a href="#cb18-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-128"><a href="#cb18-128" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb18-129"><a href="#cb18-129" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb18-130"><a href="#cb18-130" aria-hidden="true" tabindex="-1"></a><span class="co">#| label:        Random-Bits</span></span>
<span id="cb18-131"><a href="#cb18-131" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap:      "Generated Random Impulse Trains"</span></span>
<span id="cb18-132"><a href="#cb18-132" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-subcap:</span></span>
<span id="cb18-133"><a href="#cb18-133" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "Impulse Train X"</span></span>
<span id="cb18-134"><a href="#cb18-134" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "Impulse Train X Oversampled by 20 to see bits better"</span></span>
<span id="cb18-135"><a href="#cb18-135" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "Impulse Train Y"</span></span>
<span id="cb18-136"><a href="#cb18-136" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "Impulse Train Y Oversampled by 20 to see bits better"</span></span>
<span id="cb18-137"><a href="#cb18-137" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb18-138"><a href="#cb18-138" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> gen_pulse_train()</span>
<span id="cb18-139"><a href="#cb18-139" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> gen_pulse_train()</span>
<span id="cb18-140"><a href="#cb18-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-141"><a href="#cb18-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-142"><a href="#cb18-142" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb18-143"><a href="#cb18-143" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(x), <span class="st">"r.-"</span>)</span>
<span id="cb18-144"><a href="#cb18-144" aria-hidden="true" tabindex="-1"></a>plt.plot(np.imag(x), <span class="st">".-"</span>)</span>
<span id="cb18-145"><a href="#cb18-145" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Value"</span>)</span>
<span id="cb18-146"><a href="#cb18-146" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Impulse train X"</span>)</span>
<span id="cb18-147"><a href="#cb18-147" aria-hidden="true" tabindex="-1"></a>plt.xlim((<span class="dv">0</span>, Nd))</span>
<span id="cb18-148"><a href="#cb18-148" aria-hidden="true" tabindex="-1"></a>plt.ylim((<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb18-149"><a href="#cb18-149" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb18-150"><a href="#cb18-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-151"><a href="#cb18-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-152"><a href="#cb18-152" aria-hidden="true" tabindex="-1"></a>Oversampling <span class="op">=</span> <span class="dv">25</span></span>
<span id="cb18-153"><a href="#cb18-153" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb18-154"><a href="#cb18-154" aria-hidden="true" tabindex="-1"></a>plt.plot(np.repeat(np.real(x), Oversampling), <span class="st">"r.-"</span>)</span>
<span id="cb18-155"><a href="#cb18-155" aria-hidden="true" tabindex="-1"></a>plt.plot(np.repeat(np.imag(x), Oversampling), <span class="st">".-"</span>)</span>
<span id="cb18-156"><a href="#cb18-156" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Value"</span>)</span>
<span id="cb18-157"><a href="#cb18-157" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Oversampled Impulse train X"</span>)</span>
<span id="cb18-158"><a href="#cb18-158" aria-hidden="true" tabindex="-1"></a>plt.xlim((<span class="dv">0</span>, Oversampling <span class="op">*</span> Nd))</span>
<span id="cb18-159"><a href="#cb18-159" aria-hidden="true" tabindex="-1"></a>plt.ylim((<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb18-160"><a href="#cb18-160" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb18-161"><a href="#cb18-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-162"><a href="#cb18-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-163"><a href="#cb18-163" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb18-164"><a href="#cb18-164" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(y), <span class="st">"r.-"</span>)</span>
<span id="cb18-165"><a href="#cb18-165" aria-hidden="true" tabindex="-1"></a>plt.plot(np.imag(y), <span class="st">".-"</span>)</span>
<span id="cb18-166"><a href="#cb18-166" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Value"</span>)</span>
<span id="cb18-167"><a href="#cb18-167" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Impulse train Y"</span>)</span>
<span id="cb18-168"><a href="#cb18-168" aria-hidden="true" tabindex="-1"></a>plt.xlim((<span class="dv">0</span>, Nd))</span>
<span id="cb18-169"><a href="#cb18-169" aria-hidden="true" tabindex="-1"></a>plt.ylim((<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb18-170"><a href="#cb18-170" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb18-171"><a href="#cb18-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-172"><a href="#cb18-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-173"><a href="#cb18-173" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb18-174"><a href="#cb18-174" aria-hidden="true" tabindex="-1"></a>plt.plot(np.repeat(np.real(y), Oversampling), <span class="st">"r.-"</span>)</span>
<span id="cb18-175"><a href="#cb18-175" aria-hidden="true" tabindex="-1"></a>plt.plot(np.repeat(np.imag(y), Oversampling), <span class="st">".-"</span>)</span>
<span id="cb18-176"><a href="#cb18-176" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Value"</span>)</span>
<span id="cb18-177"><a href="#cb18-177" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Oversampled Impulse train Y"</span>)</span>
<span id="cb18-178"><a href="#cb18-178" aria-hidden="true" tabindex="-1"></a>plt.xlim((<span class="dv">0</span>, Oversampling <span class="op">*</span> Nd))</span>
<span id="cb18-179"><a href="#cb18-179" aria-hidden="true" tabindex="-1"></a>plt.ylim((<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb18-180"><a href="#cb18-180" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb18-181"><a href="#cb18-181" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb18-182"><a href="#cb18-182" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Interlude: Representing QPSK data</span></span>
<span id="cb18-183"><a href="#cb18-183" aria-hidden="true" tabindex="-1"></a>For QPSK we have 4 symbols that we would like to represent as IQ data. Therefore, we need a mapping from the linear {0b00, 0b01, 0b10, 0b11} to a complex {(-0.5 - j*0.5), (0.5 - j*0.5), (-0.5 + j*0.5), (0.5 + j*0.5)}</span>
<span id="cb18-186"><a href="#cb18-186" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb18-187"><a href="#cb18-187" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb18-188"><a href="#cb18-188" aria-hidden="true" tabindex="-1"></a><span class="co">#| label:        QPSK</span></span>
<span id="cb18-189"><a href="#cb18-189" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap:      "QPSK Constellation Diagram"</span></span>
<span id="cb18-190"><a href="#cb18-190" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb18-191"><a href="#cb18-191" aria-hidden="true" tabindex="-1"></a>  sym <span class="op">=</span> np.random.randint(<span class="dv">0</span>, BPS<span class="op">**</span><span class="dv">2</span>, <span class="dv">50</span>)</span>
<span id="cb18-192"><a href="#cb18-192" aria-hidden="true" tabindex="-1"></a>  s <span class="op">=</span> np.zeros(<span class="dv">200</span>, dtype<span class="op">=</span><span class="bu">complex</span>)</span>
<span id="cb18-193"><a href="#cb18-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-194"><a href="#cb18-194" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i, ss <span class="kw">in</span> <span class="bu">enumerate</span>(sym):</span>
<span id="cb18-195"><a href="#cb18-195" aria-hidden="true" tabindex="-1"></a>      s[i <span class="op">*</span> SPS] <span class="op">+=</span> (ss <span class="op">&amp;</span> <span class="bn">0b01</span>) <span class="op">-</span> <span class="fl">0.5</span></span>
<span id="cb18-196"><a href="#cb18-196" aria-hidden="true" tabindex="-1"></a>      s[i <span class="op">*</span> SPS] <span class="op">+=</span> <span class="ot">1j</span> <span class="op">*</span> (((ss <span class="op">&amp;</span> <span class="bn">0b10</span>) <span class="op">&gt;&gt;</span> <span class="dv">1</span>) <span class="op">-</span> <span class="fl">0.5</span>)</span>
<span id="cb18-197"><a href="#cb18-197" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> s[i <span class="op">*</span> SPS] <span class="op">==</span> <span class="dv">0</span> <span class="op">+</span> <span class="ot">1j</span> <span class="op">*</span> <span class="dv">0</span>:</span>
<span id="cb18-198"><a href="#cb18-198" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"zero"</span>)</span>
<span id="cb18-199"><a href="#cb18-199" aria-hidden="true" tabindex="-1"></a>        s[i <span class="op">*</span> SPS] <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="ot">1j</span> <span class="op">*</span> <span class="fl">0.5</span></span>
<span id="cb18-200"><a href="#cb18-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-201"><a href="#cb18-201" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb18-202"><a href="#cb18-202" aria-hidden="true" tabindex="-1"></a>plt.scatter(s.real, s.imag)</span>
<span id="cb18-203"><a href="#cb18-203" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Q"</span>)</span>
<span id="cb18-204"><a href="#cb18-204" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"I"</span>)</span>
<span id="cb18-205"><a href="#cb18-205" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Constellation Diagram for QPSK"</span>)</span>
<span id="cb18-206"><a href="#cb18-206" aria-hidden="true" tabindex="-1"></a>plt.text( <span class="fl">0.5</span>,  <span class="fl">0.60</span>, <span class="st">"0b11"</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb18-207"><a href="#cb18-207" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="op">-</span><span class="fl">0.5</span>,  <span class="fl">0.60</span>, <span class="st">"0b10"</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb18-208"><a href="#cb18-208" aria-hidden="true" tabindex="-1"></a>plt.text( <span class="fl">0.5</span>, <span class="op">-</span><span class="fl">0.60</span>, <span class="st">"0b01"</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb18-209"><a href="#cb18-209" aria-hidden="true" tabindex="-1"></a>plt.text(<span class="op">-</span><span class="fl">0.5</span>, <span class="op">-</span><span class="fl">0.60</span>, <span class="st">"0b00"</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb18-210"><a href="#cb18-210" aria-hidden="true" tabindex="-1"></a>plt.xlim((<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb18-211"><a href="#cb18-211" aria-hidden="true" tabindex="-1"></a>plt.ylim((<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb18-212"><a href="#cb18-212" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb18-213"><a href="#cb18-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-214"><a href="#cb18-214" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb18-215"><a href="#cb18-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-216"><a href="#cb18-216" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb18-217"><a href="#cb18-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-218"><a href="#cb18-218" aria-hidden="true" tabindex="-1"></a><span class="fu">## Pulse Shaping Our Data</span></span>
<span id="cb18-221"><a href="#cb18-221" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb18-222"><a href="#cb18-222" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb18-223"><a href="#cb18-223" aria-hidden="true" tabindex="-1"></a><span class="co">#| label:        Pulse-Shaping</span></span>
<span id="cb18-224"><a href="#cb18-224" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap:      "Pulse shaped bits to be transmitted"</span></span>
<span id="cb18-225"><a href="#cb18-225" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-subcap:</span></span>
<span id="cb18-226"><a href="#cb18-226" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "Pulse shaped TX1"</span></span>
<span id="cb18-227"><a href="#cb18-227" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "Pulse shaped TX2"</span></span>
<span id="cb18-228"><a href="#cb18-228" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb18-229"><a href="#cb18-229" aria-hidden="true" tabindex="-1"></a>tx1 <span class="op">=</span> signal.convolve(x, pulse)</span>
<span id="cb18-230"><a href="#cb18-230" aria-hidden="true" tabindex="-1"></a>tx2 <span class="op">=</span> signal.convolve(y, pulse)</span>
<span id="cb18-231"><a href="#cb18-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-232"><a href="#cb18-232" aria-hidden="true" tabindex="-1"></a><span class="co"># Convolution has the effect of making our signal a bit longer (N + Taps/2 - 1)</span></span>
<span id="cb18-233"><a href="#cb18-233" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-234"><a href="#cb18-234" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.arange(tx1.shape[<span class="dv">0</span>])</span>
<span id="cb18-235"><a href="#cb18-235" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb18-236"><a href="#cb18-236" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(tx1), <span class="st">"r.-"</span>, np.imag(tx1), <span class="st">".-"</span>)</span>
<span id="cb18-237"><a href="#cb18-237" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Value"</span>)</span>
<span id="cb18-238"><a href="#cb18-238" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"TX1"</span>)</span>
<span id="cb18-239"><a href="#cb18-239" aria-hidden="true" tabindex="-1"></a>plt.xlim((Taps<span class="op">//</span><span class="dv">2</span>, SPS <span class="op">*</span> Nd))</span>
<span id="cb18-240"><a href="#cb18-240" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb18-241"><a href="#cb18-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-242"><a href="#cb18-242" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb18-243"><a href="#cb18-243" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(tx2), <span class="st">"r.-"</span>, np.imag(tx2), <span class="st">".-"</span>)</span>
<span id="cb18-244"><a href="#cb18-244" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Value"</span>)</span>
<span id="cb18-245"><a href="#cb18-245" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"TX2"</span>)</span>
<span id="cb18-246"><a href="#cb18-246" aria-hidden="true" tabindex="-1"></a>plt.xlim((Taps<span class="op">//</span><span class="dv">2</span>, SPS <span class="op">*</span> Nd))</span>
<span id="cb18-247"><a href="#cb18-247" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb18-248"><a href="#cb18-248" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb18-249"><a href="#cb18-249" aria-hidden="true" tabindex="-1"></a>:::{.callout-note}</span>
<span id="cb18-250"><a href="#cb18-250" aria-hidden="true" tabindex="-1"></a>What we see above are signals that are more resilient to inter-symbol interference due to the RRC filter we applied on both ends of our chain. A lowpass filter is applied before and after transmission to reduce the spectrum usage of our signal (and for noise resilience).</span>
<span id="cb18-251"><a href="#cb18-251" aria-hidden="true" tabindex="-1"></a>A great article on the topic by Dr. Marc Lichtman can be found on <span class="co">[</span><span class="ot">PySDR.org</span><span class="co">](https://pysdr.org/content/pulse_shaping.html)</span>.</span>
<span id="cb18-252"><a href="#cb18-252" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb18-253"><a href="#cb18-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-256"><a href="#cb18-256" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb18-257"><a href="#cb18-257" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb18-258"><a href="#cb18-258" aria-hidden="true" tabindex="-1"></a><span class="co">#| label:        TX-IQ-Data</span></span>
<span id="cb18-259"><a href="#cb18-259" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap:      "IQ samples of TX1 and TX2"</span></span>
<span id="cb18-260"><a href="#cb18-260" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-subcap:</span></span>
<span id="cb18-261"><a href="#cb18-261" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "IQ constellation for TX1"</span></span>
<span id="cb18-262"><a href="#cb18-262" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "IQ constellation for TX2"</span></span>
<span id="cb18-263"><a href="#cb18-263" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb18-264"><a href="#cb18-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-265"><a href="#cb18-265" aria-hidden="true" tabindex="-1"></a>IQd <span class="op">=</span> <span class="dv">500</span>  <span class="co"># Raw IQ Samples to display</span></span>
<span id="cb18-266"><a href="#cb18-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-267"><a href="#cb18-267" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb18-268"><a href="#cb18-268" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"TX1 IQ Constellation"</span>)</span>
<span id="cb18-269"><a href="#cb18-269" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Quadrature"</span>)</span>
<span id="cb18-270"><a href="#cb18-270" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"In-phase"</span>)</span>
<span id="cb18-271"><a href="#cb18-271" aria-hidden="true" tabindex="-1"></a>plt.ylim((<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb18-272"><a href="#cb18-272" aria-hidden="true" tabindex="-1"></a>plt.xlim((<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb18-273"><a href="#cb18-273" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(tx1[Taps<span class="op">//</span><span class="dv">2</span>:IQd:SPS]), np.imag(tx1[Taps<span class="op">//</span><span class="dv">2</span>:IQd:SPS]), <span class="st">"."</span>)</span>
<span id="cb18-274"><a href="#cb18-274" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(x[<span class="dv">0</span>::SPS]), np.imag(x[<span class="dv">0</span>::SPS]), <span class="st">"r."</span>)</span>
<span id="cb18-275"><a href="#cb18-275" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb18-276"><a href="#cb18-276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-277"><a href="#cb18-277" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb18-278"><a href="#cb18-278" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"TX2 IQ Constellation"</span>)</span>
<span id="cb18-279"><a href="#cb18-279" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Quadrature"</span>)</span>
<span id="cb18-280"><a href="#cb18-280" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"In-phase"</span>)</span>
<span id="cb18-281"><a href="#cb18-281" aria-hidden="true" tabindex="-1"></a>plt.ylim((<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb18-282"><a href="#cb18-282" aria-hidden="true" tabindex="-1"></a>plt.xlim((<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb18-283"><a href="#cb18-283" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(tx2[Taps<span class="op">//</span><span class="dv">2</span>:IQd:SPS]), np.imag(tx2[Taps<span class="op">//</span><span class="dv">2</span>:IQd:SPS]), <span class="st">"."</span>)</span>
<span id="cb18-284"><a href="#cb18-284" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(y[<span class="dv">0</span>::SPS]), np.imag(y[<span class="dv">0</span>::SPS]), <span class="st">"r."</span>)</span>
<span id="cb18-285"><a href="#cb18-285" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb18-286"><a href="#cb18-286" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb18-287"><a href="#cb18-287" aria-hidden="true" tabindex="-1"></a>From the IQ diagrams, we can see that the two transmission signals are both clean QPSK.</span>
<span id="cb18-290"><a href="#cb18-290" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb18-291"><a href="#cb18-291" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb18-292"><a href="#cb18-292" aria-hidden="true" tabindex="-1"></a><span class="co">#| label:        TX-Correlation</span></span>
<span id="cb18-293"><a href="#cb18-293" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap:      "Correlation between TX1 and TX2"</span></span>
<span id="cb18-294"><a href="#cb18-294" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-subcap:</span></span>
<span id="cb18-295"><a href="#cb18-295" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "Autocorrelation of TX1"</span></span>
<span id="cb18-296"><a href="#cb18-296" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "Autocorrelation of TX2"</span></span>
<span id="cb18-297"><a href="#cb18-297" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "Crosscorrelation of TX1 and TX2"</span></span>
<span id="cb18-298"><a href="#cb18-298" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb18-299"><a href="#cb18-299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-300"><a href="#cb18-300" aria-hidden="true" tabindex="-1"></a>ac1 <span class="op">=</span> signal.correlate(tx1, tx1)</span>
<span id="cb18-301"><a href="#cb18-301" aria-hidden="true" tabindex="-1"></a>ac2 <span class="op">=</span> signal.correlate(tx2, tx2)</span>
<span id="cb18-302"><a href="#cb18-302" aria-hidden="true" tabindex="-1"></a>cc <span class="op">=</span> signal.correlate(tx1, tx2)</span>
<span id="cb18-303"><a href="#cb18-303" aria-hidden="true" tabindex="-1"></a>ac1 <span class="op">=</span> signal.correlate(tx1, tx1)</span>
<span id="cb18-304"><a href="#cb18-304" aria-hidden="true" tabindex="-1"></a>ac2 <span class="op">=</span> signal.correlate(tx2, tx2)</span>
<span id="cb18-305"><a href="#cb18-305" aria-hidden="true" tabindex="-1"></a>cc <span class="op">=</span> signal.correlate(tx1, tx2)</span>
<span id="cb18-306"><a href="#cb18-306" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-307"><a href="#cb18-307" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.arange(ac1.shape[<span class="dv">0</span>]) <span class="op">-</span> (ac1.shape[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb18-308"><a href="#cb18-308" aria-hidden="true" tabindex="-1"></a>top <span class="op">=</span> np.<span class="bu">max</span>((np.<span class="bu">abs</span>(ac1), np.<span class="bu">abs</span>(ac2), np.<span class="bu">abs</span>(cc)))</span>
<span id="cb18-309"><a href="#cb18-309" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-310"><a href="#cb18-310" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">4</span>))</span>
<span id="cb18-311"><a href="#cb18-311" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">131</span>)</span>
<span id="cb18-312"><a href="#cb18-312" aria-hidden="true" tabindex="-1"></a>plt.plot(t, np.<span class="bu">abs</span>(ac1), <span class="st">".-"</span>)</span>
<span id="cb18-313"><a href="#cb18-313" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Correlation"</span>)</span>
<span id="cb18-314"><a href="#cb18-314" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Autocorrelation TX1"</span>)</span>
<span id="cb18-315"><a href="#cb18-315" aria-hidden="true" tabindex="-1"></a>plt.xlim((<span class="op">-</span><span class="dv">64</span>, <span class="dv">63</span>)) <span class="co"># Display the center 128 samples</span></span>
<span id="cb18-316"><a href="#cb18-316" aria-hidden="true" tabindex="-1"></a>plt.ylim((<span class="dv">0</span>, top))</span>
<span id="cb18-317"><a href="#cb18-317" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb18-318"><a href="#cb18-318" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-319"><a href="#cb18-319" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">132</span>)</span>
<span id="cb18-320"><a href="#cb18-320" aria-hidden="true" tabindex="-1"></a>plt.plot(t, np.<span class="bu">abs</span>(cc), <span class="st">".-"</span>)</span>
<span id="cb18-321"><a href="#cb18-321" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Lag"</span>)</span>
<span id="cb18-322"><a href="#cb18-322" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Crosscorrelation TX1:TX2"</span>)</span>
<span id="cb18-323"><a href="#cb18-323" aria-hidden="true" tabindex="-1"></a>plt.xlim((<span class="op">-</span><span class="dv">64</span>, <span class="dv">63</span>))</span>
<span id="cb18-324"><a href="#cb18-324" aria-hidden="true" tabindex="-1"></a>plt.ylim((<span class="dv">0</span>, top))</span>
<span id="cb18-325"><a href="#cb18-325" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb18-326"><a href="#cb18-326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-327"><a href="#cb18-327" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">133</span>)</span>
<span id="cb18-328"><a href="#cb18-328" aria-hidden="true" tabindex="-1"></a>plt.plot(t, np.<span class="bu">abs</span>(ac2), <span class="st">".-"</span>)</span>
<span id="cb18-329"><a href="#cb18-329" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Autocorrelation TX2"</span>)</span>
<span id="cb18-330"><a href="#cb18-330" aria-hidden="true" tabindex="-1"></a>plt.xlim((<span class="op">-</span><span class="dv">64</span>, <span class="dv">63</span>))</span>
<span id="cb18-331"><a href="#cb18-331" aria-hidden="true" tabindex="-1"></a>plt.ylim((<span class="dv">0</span>, top))</span>
<span id="cb18-332"><a href="#cb18-332" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb18-333"><a href="#cb18-333" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb18-334"><a href="#cb18-334" aria-hidden="true" tabindex="-1"></a>Observe the sharp auto-correlation peaks for each transmit signal. Also observe that the transmit signals' cross-correlation is very low; they don't correlate with each other well at all. This demonstrates that our signals have the properties we expected when we constructed them.</span>
<span id="cb18-335"><a href="#cb18-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-336"><a href="#cb18-336" aria-hidden="true" tabindex="-1"></a><span class="fu"># Communication Channel Simulation</span></span>
<span id="cb18-337"><a href="#cb18-337" aria-hidden="true" tabindex="-1"></a>Our next step is to simulate the communication channel. We'll add a coarse (sample level) and fine (subsample level) delay to TX2. We'll then sum the two signals together. Finally, we'll add some additive white gaussian noise (AWGN).</span>
<span id="cb18-338"><a href="#cb18-338" aria-hidden="true" tabindex="-1"></a>We can also simulate mulitipath effects by passing the channel through a special sort of filter that emulates the effect of our signal being delayed by bouncing around and not taking a straight line path.</span>
<span id="cb18-339"><a href="#cb18-339" aria-hidden="true" tabindex="-1"></a>Again, a great resource is PySDR.org which has a section on <span class="co">[</span><span class="ot">multipath fading</span><span class="co">](https://pysdr.org/content/multipath_fading.html)</span>.</span>
<span id="cb18-340"><a href="#cb18-340" aria-hidden="true" tabindex="-1"></a>As the signals </span>
<span id="cb18-341"><a href="#cb18-341" aria-hidden="true" tabindex="-1"></a>Both our Tx signals don't necessarily have to take the same path to get to the receiver either, making it even harder to imagine what the delays and attenuations both signals went through to get to the Rx1.</span>
<span id="cb18-342"><a href="#cb18-342" aria-hidden="true" tabindex="-1"></a>For now let's assume we have no fading as our channel stays constant through time (meaning the environment throgh which our signals propagate remains unchanging.) Otherwise, we would also have to account for a signal to noise ratio that changes with time as either our Tx's, our Rx, or our environment changes.</span>
<span id="cb18-343"><a href="#cb18-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-344"><a href="#cb18-344" aria-hidden="true" tabindex="-1"></a>To keep things uncomplicated, let's just model our channel impulse response as something simple that will still account for the delays and attenuation from our signal going outside our line of sight.</span>
<span id="cb18-347"><a href="#cb18-347" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb18-348"><a href="#cb18-348" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: false</span></span>
<span id="cb18-349"><a href="#cb18-349" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> apply_fractional_delay(s, delay<span class="op">=</span><span class="fl">0.4</span>):</span>
<span id="cb18-350"><a href="#cb18-350" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create and apply fractional delay filter</span></span>
<span id="cb18-351"><a href="#cb18-351" aria-hidden="true" tabindex="-1"></a>    <span class="co"># delay is fractional delay, in samples</span></span>
<span id="cb18-352"><a href="#cb18-352" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="dv">23</span></span>
<span id="cb18-353"><a href="#cb18-353" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> np.arange(<span class="op">-</span>N <span class="op">//</span> <span class="dv">2</span>, N <span class="op">//</span> <span class="dv">2</span>)</span>
<span id="cb18-354"><a href="#cb18-354" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> np.sinc(n <span class="op">-</span> delay)</span>
<span id="cb18-355"><a href="#cb18-355" aria-hidden="true" tabindex="-1"></a>    h <span class="op">*=</span> np.hamming(N)  <span class="co"># Window the filter to avoid edge artifacts</span></span>
<span id="cb18-356"><a href="#cb18-356" aria-hidden="true" tabindex="-1"></a>    h <span class="op">/=</span> np.<span class="bu">sum</span>(h)  <span class="co"># Normalize</span></span>
<span id="cb18-357"><a href="#cb18-357" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.convolve(s, h)</span>
<span id="cb18-358"><a href="#cb18-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-359"><a href="#cb18-359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-360"><a href="#cb18-360" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> apply_sample_delay(s, delay<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb18-361"><a href="#cb18-361" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.concatenate((np.zeros(delay), s))</span>
<span id="cb18-362"><a href="#cb18-362" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-363"><a href="#cb18-363" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-364"><a href="#cb18-364" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> apply_frequency_offset(s, fo<span class="op">=</span><span class="fl">13e3</span>):</span>
<span id="cb18-365"><a href="#cb18-365" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simulate a frequency offset (fo)</span></span>
<span id="cb18-366"><a href="#cb18-366" aria-hidden="true" tabindex="-1"></a>    Ts <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> Fs  <span class="co"># Sample period</span></span>
<span id="cb18-367"><a href="#cb18-367" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> np.linspace(<span class="dv">0</span>, Ts <span class="op">*</span> <span class="bu">len</span>(s), <span class="bu">len</span>(s))</span>
<span id="cb18-368"><a href="#cb18-368" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s <span class="op">*</span> np.exp(<span class="ot">1j</span> <span class="op">*</span> <span class="dv">2</span> <span class="op">*</span> np.pi <span class="op">*</span> fo <span class="op">*</span> t)  <span class="co"># Shift frequency by fo</span></span>
<span id="cb18-369"><a href="#cb18-369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-370"><a href="#cb18-370" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-371"><a href="#cb18-371" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> apply_noise(s, level<span class="op">=</span><span class="fl">0.3</span>):</span>
<span id="cb18-372"><a href="#cb18-372" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simulate adding AWGN</span></span>
<span id="cb18-373"><a href="#cb18-373" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="bu">len</span>(s)  <span class="co"># Number of samples</span></span>
<span id="cb18-374"><a href="#cb18-374" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> (np.random.randn(N) <span class="op">+</span> <span class="ot">1j</span> <span class="op">*</span> np.random.randn(N)) <span class="op">/</span> np.sqrt(<span class="dv">2</span>)</span>
<span id="cb18-375"><a href="#cb18-375" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s <span class="op">+</span> n <span class="op">*</span> level</span>
<span id="cb18-376"><a href="#cb18-376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-377"><a href="#cb18-377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-378"><a href="#cb18-378" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> apply_channel_multipath(s):</span>
<span id="cb18-379"><a href="#cb18-379" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Multipath for a channel using randomly selected values for attenuation and delay.</span></span>
<span id="cb18-380"><a href="#cb18-380" aria-hidden="true" tabindex="-1"></a>    <span class="co"># A better analysis would incorporate Rayleigh or Rician fading.</span></span>
<span id="cb18-381"><a href="#cb18-381" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This is only a first approximation.</span></span>
<span id="cb18-382"><a href="#cb18-382" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="fl">0.5</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="fl">0.12</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="fl">0.001</span>])</span>
<span id="cb18-383"><a href="#cb18-383" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.convolve(s, h)</span>
<span id="cb18-384"><a href="#cb18-384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-385"><a href="#cb18-385" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-386"><a href="#cb18-386" aria-hidden="true" tabindex="-1"></a><span class="co"># Note: We extend the TX1 signal by the delay amount, so that we can later sum the TX signals when simulating</span></span>
<span id="cb18-387"><a href="#cb18-387" aria-hidden="true" tabindex="-1"></a><span class="co"># our receive channel.</span></span>
<span id="cb18-388"><a href="#cb18-388" aria-hidden="true" tabindex="-1"></a>delay <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb18-389"><a href="#cb18-389" aria-hidden="true" tabindex="-1"></a>tx1d <span class="op">=</span> np.append(tx1, np.zeros(delay))</span>
<span id="cb18-390"><a href="#cb18-390" aria-hidden="true" tabindex="-1"></a>tx2d <span class="op">=</span> apply_sample_delay(tx2, delay)</span>
<span id="cb18-391"><a href="#cb18-391" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-392"><a href="#cb18-392" aria-hidden="true" tabindex="-1"></a><span class="co"># Note: We apply fractional delay to both TX signals as we want to delay both equally by the filter length.</span></span>
<span id="cb18-393"><a href="#cb18-393" aria-hidden="true" tabindex="-1"></a><span class="co"># Without this, TX2 would seem to arrive much later than TX1.</span></span>
<span id="cb18-394"><a href="#cb18-394" aria-hidden="true" tabindex="-1"></a>tx1d <span class="op">=</span> apply_fractional_delay(tx1d, <span class="dv">0</span>)</span>
<span id="cb18-395"><a href="#cb18-395" aria-hidden="true" tabindex="-1"></a>tx2d <span class="op">=</span> apply_fractional_delay(tx2d, <span class="fl">0.5</span>)</span>
<span id="cb18-396"><a href="#cb18-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-397"><a href="#cb18-397" aria-hidden="true" tabindex="-1"></a>rx1 <span class="op">=</span> (tx1d <span class="op">+</span> tx2d) <span class="op">/</span> np.sqrt(<span class="dv">2</span>)</span>
<span id="cb18-398"><a href="#cb18-398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-399"><a href="#cb18-399" aria-hidden="true" tabindex="-1"></a><span class="co"># Note: Even a relatively small frequency offset confuses the correlation process we use</span></span>
<span id="cb18-400"><a href="#cb18-400" aria-hidden="true" tabindex="-1"></a><span class="co"># to measure when we received the signal. For example, with a sample rate of 20 MHz, an offset</span></span>
<span id="cb18-401"><a href="#cb18-401" aria-hidden="true" tabindex="-1"></a><span class="co"># of 13 kHz causes us to be unable to see clear correlation spikes for the two TX signals,</span></span>
<span id="cb18-402"><a href="#cb18-402" aria-hidden="true" tabindex="-1"></a><span class="co"># but we can still see clear # peaks with a smaller offset of 500 Hz. Perhaps other waveforms</span></span>
<span id="cb18-403"><a href="#cb18-403" aria-hidden="true" tabindex="-1"></a><span class="co"># than "random QPSK" would survive larger offsets better.</span></span>
<span id="cb18-404"><a href="#cb18-404" aria-hidden="true" tabindex="-1"></a>rx1 <span class="op">=</span> apply_frequency_offset(rx1, <span class="dv">0</span>)</span>
<span id="cb18-405"><a href="#cb18-405" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-406"><a href="#cb18-406" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb18-407"><a href="#cb18-407" aria-hidden="true" tabindex="-1"></a><span class="fu">## Analysis</span></span>
<span id="cb18-408"><a href="#cb18-408" aria-hidden="true" tabindex="-1"></a>Now, we'll analyze the received data. First, we'll filter the received data with the RRC filter composed previously, giving the overall communication channel an RC response and minimizing ISI. Second, we resample the received data; this allows us to observe properties of the received signal with subsample precision. Finally, we cross-correlate the received signals with each transmit signal; this shows us where the transmitted signals are within the receive data. We should see any delay we added here by observing the distance between cross-correlation peaks.</span>
<span id="cb18-409"><a href="#cb18-409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-410"><a href="#cb18-410" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-411"><a href="#cb18-411" aria-hidden="true" tabindex="-1"></a>So what does our signal look like after passing through the channel?</span>
<span id="cb18-414"><a href="#cb18-414" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb18-415"><a href="#cb18-415" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb18-416"><a href="#cb18-416" aria-hidden="true" tabindex="-1"></a><span class="co">#| label:        Signal-at-RX</span></span>
<span id="cb18-417"><a href="#cb18-417" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap:      "Signal at receiver"</span></span>
<span id="cb18-418"><a href="#cb18-418" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-subcap:</span></span>
<span id="cb18-419"><a href="#cb18-419" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "Signal with just delays and frequency offset"</span></span>
<span id="cb18-420"><a href="#cb18-420" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "Channel impulse response"</span></span>
<span id="cb18-421"><a href="#cb18-421" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "Signal also modelling multipath"</span></span>
<span id="cb18-422"><a href="#cb18-422" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "Signal with delays, frequency offset, multipath, and channel noise"</span></span>
<span id="cb18-423"><a href="#cb18-423" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb18-424"><a href="#cb18-424" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-425"><a href="#cb18-425" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb18-426"><a href="#cb18-426" aria-hidden="true" tabindex="-1"></a>plt.plot(rx1[<span class="dv">100</span>:<span class="dv">250</span>], <span class="st">'-'</span>)</span>
<span id="cb18-427"><a href="#cb18-427" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Magnitude"</span>)</span>
<span id="cb18-428"><a href="#cb18-428" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Time"</span>)</span>
<span id="cb18-429"><a href="#cb18-429" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Signal with just delays and frequency offset"</span>)</span>
<span id="cb18-430"><a href="#cb18-430" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb18-431"><a href="#cb18-431" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-432"><a href="#cb18-432" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb18-433"><a href="#cb18-433" aria-hidden="true" tabindex="-1"></a>plt.stem(apply_channel_multipath(np.array([<span class="dv">1</span>])), <span class="st">'.'</span>)</span>
<span id="cb18-434"><a href="#cb18-434" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Magnitude"</span>)</span>
<span id="cb18-435"><a href="#cb18-435" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Time"</span>)</span>
<span id="cb18-436"><a href="#cb18-436" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Channel impulse response"</span>)</span>
<span id="cb18-437"><a href="#cb18-437" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb18-438"><a href="#cb18-438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-439"><a href="#cb18-439" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb18-440"><a href="#cb18-440" aria-hidden="true" tabindex="-1"></a>plt.plot(apply_channel_multipath(rx1[<span class="dv">100</span>:<span class="dv">250</span>]), <span class="st">'-'</span>)</span>
<span id="cb18-441"><a href="#cb18-441" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Magnitude"</span>)</span>
<span id="cb18-442"><a href="#cb18-442" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Time"</span>)</span>
<span id="cb18-443"><a href="#cb18-443" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Signal with delays, frequency offset AND multichannel"</span>)</span>
<span id="cb18-444"><a href="#cb18-444" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb18-445"><a href="#cb18-445" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-446"><a href="#cb18-446" aria-hidden="true" tabindex="-1"></a>rx1 <span class="op">=</span> apply_noise(rx1)</span>
<span id="cb18-447"><a href="#cb18-447" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb18-448"><a href="#cb18-448" aria-hidden="true" tabindex="-1"></a>plt.plot(apply_channel_multipath(rx1[<span class="dv">100</span>:<span class="dv">250</span>]), <span class="st">'-'</span>)</span>
<span id="cb18-449"><a href="#cb18-449" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Magnitude"</span>)</span>
<span id="cb18-450"><a href="#cb18-450" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Time"</span>)</span>
<span id="cb18-451"><a href="#cb18-451" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Signal with delays, frequency offset, mulitipath AND noise"</span>)</span>
<span id="cb18-452"><a href="#cb18-452" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb18-453"><a href="#cb18-453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-454"><a href="#cb18-454" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb18-455"><a href="#cb18-455" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-456"><a href="#cb18-456" aria-hidden="true" tabindex="-1"></a>Wow</span>
<span id="cb18-457"><a href="#cb18-457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-458"><a href="#cb18-458" aria-hidden="true" tabindex="-1"></a><span class="al">![...](https://media1.tenor.com/m/DATRxbxadaoAAAAC/a-lot-of-damage.gif "that's a lotta damage")</span></span>
<span id="cb18-459"><a href="#cb18-459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-462"><a href="#cb18-462" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb18-463"><a href="#cb18-463" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: false</span></span>
<span id="cb18-464"><a href="#cb18-464" aria-hidden="true" tabindex="-1"></a><span class="co"># Now that our channel is simulated, complete with signal and noise, let's filter at the receive end</span></span>
<span id="cb18-465"><a href="#cb18-465" aria-hidden="true" tabindex="-1"></a><span class="co"># with our RRC filter. This will make the end-to-end channel response that of a raised cosine filter,</span></span>
<span id="cb18-466"><a href="#cb18-466" aria-hidden="true" tabindex="-1"></a><span class="co"># which is good for minimizing ISI.</span></span>
<span id="cb18-467"><a href="#cb18-467" aria-hidden="true" tabindex="-1"></a>rx1 <span class="op">=</span> signal.convolve(rx1, pulse)</span>
<span id="cb18-468"><a href="#cb18-468" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb18-469"><a href="#cb18-469" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-472"><a href="#cb18-472" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb18-473"><a href="#cb18-473" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: false</span></span>
<span id="cb18-474"><a href="#cb18-474" aria-hidden="true" tabindex="-1"></a><span class="co"># Interpolate signal, so we can correlate with sub-sample accuracy</span></span>
<span id="cb18-475"><a href="#cb18-475" aria-hidden="true" tabindex="-1"></a>RS <span class="op">=</span> <span class="dv">10</span>  <span class="co"># Increase signal length by RS times (e.g. 10x for RS 10)</span></span>
<span id="cb18-476"><a href="#cb18-476" aria-hidden="true" tabindex="-1"></a>rx1i <span class="op">=</span> signal.resample(rx1, np.shape(rx1)[<span class="dv">0</span>] <span class="op">*</span> RS)</span>
<span id="cb18-477"><a href="#cb18-477" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-478"><a href="#cb18-478" aria-hidden="true" tabindex="-1"></a><span class="co"># We also need to interpolate the TX signals for comparison</span></span>
<span id="cb18-479"><a href="#cb18-479" aria-hidden="true" tabindex="-1"></a>tx1i <span class="op">=</span> signal.resample(tx1, np.shape(tx1)[<span class="dv">0</span>] <span class="op">*</span> RS)</span>
<span id="cb18-480"><a href="#cb18-480" aria-hidden="true" tabindex="-1"></a>tx2i <span class="op">=</span> signal.resample(tx2, np.shape(tx2)[<span class="dv">0</span>] <span class="op">*</span> RS)</span>
<span id="cb18-481"><a href="#cb18-481" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb18-482"><a href="#cb18-482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-485"><a href="#cb18-485" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb18-486"><a href="#cb18-486" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb18-487"><a href="#cb18-487" aria-hidden="true" tabindex="-1"></a><span class="co">#| label:        Interpolating-Signal</span></span>
<span id="cb18-488"><a href="#cb18-488" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap:      "Interpolating a signal to 'see' with sub-sample accuracy"</span></span>
<span id="cb18-489"><a href="#cb18-489" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-subcap:</span></span>
<span id="cb18-490"><a href="#cb18-490" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "Autocorrelation of TX1"</span></span>
<span id="cb18-491"><a href="#cb18-491" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "Autocorrelation of TX2"</span></span>
<span id="cb18-492"><a href="#cb18-492" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "Crosscorrelation of TX1 and TX2"</span></span>
<span id="cb18-493"><a href="#cb18-493" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb18-494"><a href="#cb18-494" aria-hidden="true" tabindex="-1"></a>Nd <span class="op">=</span> RS  <span class="co"># Number of samples to display</span></span>
<span id="cb18-495"><a href="#cb18-495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-496"><a href="#cb18-496" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">4</span>))</span>
<span id="cb18-497"><a href="#cb18-497" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">131</span>)</span>
<span id="cb18-498"><a href="#cb18-498" aria-hidden="true" tabindex="-1"></a>plt.plot(np.<span class="bu">abs</span>(rx1[:Nd]), <span class="st">"bx-"</span>)</span>
<span id="cb18-499"><a href="#cb18-499" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Value"</span>)</span>
<span id="cb18-500"><a href="#cb18-500" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Before interpolation"</span>)</span>
<span id="cb18-501"><a href="#cb18-501" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb18-502"><a href="#cb18-502" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-503"><a href="#cb18-503" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">132</span>)</span>
<span id="cb18-504"><a href="#cb18-504" aria-hidden="true" tabindex="-1"></a>plt.plot(np.<span class="bu">abs</span>(rx1i[: Nd <span class="op">*</span> RS <span class="op">-</span> Nd]), <span class="st">"bx-"</span>)</span>
<span id="cb18-505"><a href="#cb18-505" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Value"</span>)</span>
<span id="cb18-506"><a href="#cb18-506" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"After interpolation"</span>)</span>
<span id="cb18-507"><a href="#cb18-507" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb18-508"><a href="#cb18-508" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb18-509"><a href="#cb18-509" aria-hidden="true" tabindex="-1"></a>Now let's use the crosscorrelation to see the delay between the transmitted and received signals.</span>
<span id="cb18-512"><a href="#cb18-512" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb18-513"><a href="#cb18-513" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: false</span></span>
<span id="cb18-514"><a href="#cb18-514" aria-hidden="true" tabindex="-1"></a><span class="co">#| label:        Interpolated-Sample-Delays</span></span>
<span id="cb18-515"><a href="#cb18-515" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap:      "Interpolated sample delays between Rx and Tx channels"</span></span>
<span id="cb18-516"><a href="#cb18-516" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-subcap:</span></span>
<span id="cb18-517"><a href="#cb18-517" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "Autocorrelation of TX1"</span></span>
<span id="cb18-518"><a href="#cb18-518" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "Autocorrelation of TX2"</span></span>
<span id="cb18-519"><a href="#cb18-519" aria-hidden="true" tabindex="-1"></a><span class="co">#|  - "Crosscorrelation of TX1 and TX2"</span></span>
<span id="cb18-520"><a href="#cb18-520" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-align: center</span></span>
<span id="cb18-521"><a href="#cb18-521" aria-hidden="true" tabindex="-1"></a>rtx1 <span class="op">=</span> np.<span class="bu">abs</span>(signal.correlate(rx1i, tx1i, <span class="st">"valid"</span>))</span>
<span id="cb18-522"><a href="#cb18-522" aria-hidden="true" tabindex="-1"></a>rtx2 <span class="op">=</span> np.<span class="bu">abs</span>(signal.correlate(rx1i, tx2i, <span class="st">"valid"</span>))</span>
<span id="cb18-523"><a href="#cb18-523" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>))</span>
<span id="cb18-524"><a href="#cb18-524" aria-hidden="true" tabindex="-1"></a>plt.plot(rtx1[: <span class="dv">100</span> <span class="op">*</span> RS], <span class="st">"r.-"</span>)</span>
<span id="cb18-525"><a href="#cb18-525" aria-hidden="true" tabindex="-1"></a>max_tx1 <span class="op">=</span> np.argmax(rtx1[: <span class="dv">100</span> <span class="op">*</span> RS])</span>
<span id="cb18-526"><a href="#cb18-526" aria-hidden="true" tabindex="-1"></a>plt.axvline(x<span class="op">=</span>max_tx1, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb18-527"><a href="#cb18-527" aria-hidden="true" tabindex="-1"></a>plt.text(max_tx1 <span class="op">+</span> <span class="dv">3</span>,  <span class="dv">34500</span>, <span class="ss">f"Delay of </span><span class="sc">{</span>max_tx1<span class="sc">}</span><span class="ss"> samples."</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb18-528"><a href="#cb18-528" aria-hidden="true" tabindex="-1"></a>plt.plot(rtx2[: <span class="dv">100</span> <span class="op">*</span> RS], <span class="st">".-"</span>)</span>
<span id="cb18-529"><a href="#cb18-529" aria-hidden="true" tabindex="-1"></a>max_tx2 <span class="op">=</span> np.argmax(rtx2[: <span class="dv">100</span> <span class="op">*</span> RS])</span>
<span id="cb18-530"><a href="#cb18-530" aria-hidden="true" tabindex="-1"></a>plt.axvline(x<span class="op">=</span>max_tx2, color<span class="op">=</span><span class="st">'b'</span>)</span>
<span id="cb18-531"><a href="#cb18-531" aria-hidden="true" tabindex="-1"></a>plt.text(max_tx2 <span class="op">+</span> <span class="dv">3</span>,  <span class="dv">36500</span>, <span class="ss">f"Delay of </span><span class="sc">{</span>max_tx2<span class="sc">}</span><span class="ss"> samples."</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb18-532"><a href="#cb18-532" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb18-533"><a href="#cb18-533" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Interpolated sample number"</span>)</span>
<span id="cb18-534"><a href="#cb18-534" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Correlation value"</span>)</span>
<span id="cb18-535"><a href="#cb18-535" aria-hidden="true" tabindex="-1"></a>plt.legend((<span class="st">"TX1"</span>, <span class="st">"TX2"</span>))</span>
<span id="cb18-536"><a href="#cb18-536" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Location of received TX signals"</span>)</span>
<span id="cb18-537"><a href="#cb18-537" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb18-538"><a href="#cb18-538" aria-hidden="true" tabindex="-1"></a>Observe that our delays are in the interpolated sample scale (so we can do sub-sample estimation with any amount of accuracy). Once we obtain these numbers we go back to our actual samples which are a factor of <span class="in">`RS`</span> smaller.</span>
<span id="cb18-539"><a href="#cb18-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-542"><a href="#cb18-542" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb18-543"><a href="#cb18-543" aria-hidden="true" tabindex="-1"></a>txdelay <span class="op">=</span> (max_tx2 <span class="op">-</span> max_tx1) <span class="op">/</span> RS</span>
<span id="cb18-544"><a href="#cb18-544" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-545"><a href="#cb18-545" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"TX2 is behind TX1 by </span><span class="sc">{</span>txdelay<span class="sc">:4f}</span><span class="ss"> samples"</span>)</span>
<span id="cb18-546"><a href="#cb18-546" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb18-547"><a href="#cb18-547" aria-hidden="true" tabindex="-1"></a><span class="fu"># Results</span></span>
<span id="cb18-548"><a href="#cb18-548" aria-hidden="true" tabindex="-1"></a>We see that the TX2 signal was delayed by approximately 2.5 samples relative to TX1, as intended. Our coarse (per sample) and fine (subsample) delays applied when simulating our communication channel are visible in the plot as the difference in interpolated samples between the two correlation peaks.</span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>